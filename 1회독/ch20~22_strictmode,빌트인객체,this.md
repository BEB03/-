# ch20. strict mode

js는 문법의 자유도가 높고 js엔진은 개발자의 의도와 맞지 않을 수 있는 암묵적인 처리를 많이 한다.  
그래서 문법을 좀 더 엄격히 적용하여 오류 가능성이 높거나 최적화 작업에 문제가 될 수 있는 코드에 대해 명시적인 오류를 발생시킨다고 한다.

```js
"use strict";

// 코드 작성

function foo() {
  "use strict"; // 함수 몸체 첫 부분에 선언해서 해당 함수와 중첩 함수에 적용가능하다.

  // 코드 작성
}
```

## 적용 범위

전역에 선언시 스크립트 단위로 적용이 된다. 이는 일괄적이지 않으며 서드파티 라이브러리를 사용할 때 문제가 될 수도 있다.
함수 내부의 처음에 선언시 함수 단위로 적용된다. 이는 일괄적이지 않을 수 있으며 적용된 함수가 적용되지 않은 함수를 참조할 때 문제가 될 수도 있다.
따라서 즉시 실행 함수르 감싼 스크립트 단위로 적용하는 것이 좋다고 한다.

## 에러가 발생하는 경우

- 선언하지 않은 변수를 참조하면 암묵적 전역을 생성하지 않고 오류를 반환한다.
- delete 연산자로 변수, 함수, 매개변수를 삭제할 떄
- 매개변수 이름이 중복될 때
- with문의 사용

- [ ] with 문

## 바뀌는 것

- 일반 함수 호출시 해당 함수의 this가 전역 객체가 아닌 undefined가 바인딩된다.
- 매개변수에 전달된 인수를 재할당해도 arguments 객체에 반영되지 않는다.

# ch21. 빌트인 객체

## 객체의 분류

- 표준 빌트인 객체 : ECMAscript 사양에 정의된 객체, js 실행 환경과 상관없이 사용 가능, 전역 객체의 프로퍼티이다.
- 호스트 객체 : ECMAscript 사양이 아닌 실행 환경에서 추가로 제공하는 객체, 따라서 브라우저에서 제공하는 호스트 객체 (DOM, XMLHttpRequest 등등...) 와 노드에서 제공하는 고유 api는 호환되지 않음.
- 사용자 정의 객체 : 사용자가 직접 정의한 것

- [ ] 저 고유 api가 뭘까

## 표준 빌트인 객체

자바스크립트는 40여가지의 표준 빌트인 객체를 제공하며 Math, Reflect, JSON을 제외한 나머지는 생성자 함수 객체이다. (= new 연산자로 인스턴스를 생성 가능하다.)  
Math, Reflect, JSON은 정적 메서드를 제공하고 (객체니까 메서드가 있을 수 있음) 나머지 빌트인 객체는 정적 메서드와 프로토타입 메서드를 제공한다. (새로 인스턴스 만들면 상속할 수 있으니까)

## 원시값과 래퍼 객체

표준 빌트인 객체 중에서 String, Number ... 등은 왜 존재하는 것일까?

원시값(마치 객체처럼) 마침표 표기법이나 대괄호 표기법으로 접근하면 객체처럼 동작하여서 표준 빌트인 객체의 프로퍼티와 메서드를 사용할 수 있다. 이는 js 엔진이 일시적으로 원시값을 연관된 객체로 변환 후 프로퍼티 메서드를 사용하고 다시 원시값으로 되돌리기 때문이다. 이때 임시 생성되는 객체를 래퍼 객체라고 부른다.

따라서 원시값을 (필요한 경우) 객체처럼 사용해 표준 빌트인 객체의 프로퍼티와 메서드를 사용할 수 있으므로 원시값과 연관있는 생성자 함수를 new를 사용해 인스턴스를 생성할 필요가 없으며 권장되지도 않는다고 한다.

## 전역 객체

코드 실행 전에 js 엔진이 만드는 특수한 객체이다. 브라우저에서는 window, 노드에서는 global을 이름으로 가진다.  
이 객체는 표준 빌트인 객체, 실행 환경에 따른 호스트 객체, 전역에 선언한 함수와 var, 암묵적 전역을 프로퍼티로 가진다.

### **그 외 특징**

- 전역 객체를 생성하는 생성자 함수는 없다.
- 참조시 이름을 생략할 수 있음.
- 브라우저 환경의 모든 js 코드는 하나의 전역 객체를 공유한다.
- let, const는 전역으로 생성해도 전역 객체의 프로퍼티가 되지 않는다.

### 빌트인 전역 프로퍼티

전역 '객체'이므로 프로퍼티를 가지고 있다. 전역 객체가 가지는 프로퍼티를 빌트인 전역 프로퍼티라고 한다.

- Infinity : 값으로 무한대를 나타내는 number 타입의 Infinity를 가진다.
- NaN : 값으로 '숫자가 아님'을 나타내는 number 타입의 NaN을 가진다.
- undefined : 값으로 원시 타입 undefined를 가진다.

### 빌트인 전역 함수

이번엔 전역 객체의 메서드이다.

- eval : js 코드를 나타내는 문자열을 인수로 받는다. 해당 코드(문자열)를 런타임에 실행한다. 보안과 처리 속도의 문제로 사용하지 말아야 한다.
- isFinite : 인수가 유한수이면 true, 무한수또는 NaN으로 평가되면 false를 반환한다.
- parseFloat : 문자열을 인수로 받아서 실수로 해석한 값을 반환한다. 숫자 변환이 불가능 하면 NaN을 반환한다.
- parseInt : 위와 같으나 정수로 해석한 값을 반환한다.
- encodeURI : 완전한 URI를 문자열로 받아서 모든 시스템에서 읽을 수 있는 아스키 문자 셋으로 변환하는 이스케이프 처리를 한다. (외국어나 일부 특수문자의 경우는 URI 표준에 없어서 시스템마다 해석시 문제가 생길 수 있음)
- decodeURI : 인코딩된 URI를 이스케이프 처리 전으로 되돌린다.
- encodeURIcomponent : encodeURI와 같은 역할을 하나 인수를 완전한 형식의 URI가 아닌 URI의 일부인 쿼리 스트링으로 간주하므로 쿼리 스트링 구분자로 사용되는 특수문자도 인코딩한다.
- decodeURIcomponent : encodeURIcomponent로 인코딩된 URI를 원래대로 되돌린다.

```
추가 설명 : URI에서 = ? & 등은 특수한 기능들을 하기 때문에 완벽한 URI라면 = ? & 가 그에 맞는 특수 기능을 하기 위해서 인코딩이 되면 안되기 때문에 encodeURI()는 그런 예외들을 인코딩하지 않는다. 반면 쿼리 스트링 내에서 = ? & 등이 쓰인 경우 해당 문자들은 그냥 정보를 나타내는 것이지 URI의 특수 기능을 하는 것이 아니기 때문에 encodeURIcomponent()에서는 해당 문자들도 인코딩 한다.
```

- [ ] 그런데 그냥 encodeURIcomponent()만 써도 문제 없을 것 같은데? 용례를 좀 찾아봐야 이해가 잘 되겠다.

## ch22. this

## 함수 호출 방식과 this 바인딩

위에서 적었던 대로 함수 호출 방식에 따라 this에 바인딩 될 객체가 달라진다.

### 일반 함수 호출

이 경우 this에는 전역 객체가 바인딩된다. this는 객체의 프로퍼티나 메서드를 참조하기 위해서 만들어진 것이므로 이 경우에는 쓸모가 없다. (전역 객체의 프로퍼티와 메서드는 그냥 사용하면 되기 때문에)
중요한 것은 중첩 함수나 콜백 함수도 일반 함수 호출로 이루어지면 this에 전역 객체가 바인딩 된다는 것이다.  
메서드 내에서 중첩 함수나 콜백 함수를 사용한다는 것은 외부 함수의 기능을 보조하거나 대신할 의도일 텐데, 이 경우에 외부 함수(메서드)의 this(메서드를 호출한 객체)와 중첩 / 콜백 함수의 this(전역 객체)가 일치하지 않는 다는 것은 중첩 / 콜백 함수를 효율적이지 사용할 수 없게 되는 설계 방식이다.

이를 해결하기 위한 방법은 다음과 같다.

- 메서드(외부 함수)에서 this를 다른 변수에 할당한 후 중첩 / 콜백 함수에서 해당 변수를 참조한다.
- this를 명시적으로 바인딩할 수 있는 메서드를 사용한다.
- 중첩 / 콜백 함수로 화살표 함수를 사용한다.

### 메서드 호출

위에서 잠깐 언급하였듯 메서드 내부에서 this는 해당 메서드를 호출한 객체가 바인딩된다. 주의할 것은 해당 메서드를 '소유'한 객체가 아니라는 것이다.  
메서드라는 것은 프로퍼티에 바인딩된 함수라는 것으로 메서드는 해당 객체에 포함된 것이 아니라 독립적으로 존재하는 별도의 객체이기 때문이라는 설명이다.

- [ ] 그렇다면 프로퍼티의 값으로 (함수가 아닌) 객체를 가진다면 해당 객체또한 독립적으로 존재하게 되는 것일까?

어쨋든 상기한 이유로 어떤 객체에서 정의한 메서드를 다른 객체의 메서드로 할당해 사용하는 것이 가능하고 이때 this는 해당 메서드를 '호출'한 객체가 바인딩된다.

### 생성자 함수 호출

생성자 함수가 생성하게 될 인스턴스에 this가 바인딩된다. (new와 함께 호출시 암묵적으로 생성되는 빈 객체에 this가 바인딩되고 인스턴스 초기화가 이어서 진행된다.)

### 간접 호출

Function.prototype.apply/call/bin는 Function.prototype의 메서드로 모든 함수가 사용이 가능하다.

### apply / call

this로 사용할 객체와 인수 리스트를 전달받아 함수를 호출한다. 유사 배열 객체에 배열 메서드를 사용할 때 쓴다는데 추후에 배열 파트를 공부할 때 보자.

```js
함수명.apply(또는 call)(this에 바인딩할 객체);
```

### bind

apply call 과 달리 함수를 호출하지 않고, 첫 번쨰 인수로 전달한 값을 this에 바인딩한 함수롤 새롭게 생성하여 반환한다.  
**일반 함수 호출**에서 확인한 중첩 / 콜백 함수와 메서드의 this 바인딩이 불일치하는 문제를 해결할 수 있다.

```js
const person = {
  name: "jay",
  foo(callback) {
    console.log(this.name); // this = 해당 메소드를 호출한 person 객체
    setTimeout(callback, 1000); // this = callback을 일반 호출했으므로 전역 객체
    setTimeout(callback.bind(this), 1000); // this = bind에 인수로 전달한 this (= person 객체)
  },
};

person.foo(function () {
  console.log(`name : ${this.name}`);
});

/*
결과 : 
jay
name : 
name : jay
*/
```
