# ch04. 변수

## 변수

하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 공간을 식별하기 위해 붙인 이름.

식별자(변수)는 값 자체가 아니라 값이 있는 메모리 주소를 기억하고 있다.
또한 식별자는 변수 이름에만 국한되지 않는다. 함수, 클래스의 이름도 식별자라고부른다,

## 선언과 호이스팅

변수 선언은 소스 코드가 위에서부터 차례로 실행되는 시점인 **런타임**에 이루어 지는 것이 아니라, 그 이전 단계에서 먼저 실행되므로 런타임에서 변수를 참조할 때 참조하는 코드가 선언하는 코드보다 위에 있어서 (이미 선언이 완료되었기 때문에) 참조를 할 수가 있다.

이렇게 변수 선언문이 코드의 제일 처음으로 끌어올려지는 것처럼 동작하는 js의 특성을 **호이스팅**이라고 한다.
변수 선언 뿐만 아니라 모든 선언문은 런타임 이전에 실행되므로 호이스팅이 적용된다.

## 할당

할당은 런타임에 실행된다. 따라서 선언 코드보다 참조 코드가 위에 있다면 호이스팅에 의해 참조는 가능하나 엔진에 의해 초기화된 undifined값을 받게 된다.

## 재할당

재할당은 변수에 선언한 값을 변경한다. 다만 이는 원래 변수가 가리키고 있던 메모리 공간의 값을 직접 바꾸는게 아닌 새운 메모리 공간에 값을 저장하고 식별자를 연결한다. 그리고 식별자에 연결되지 않게된 값은 가비지 콜렉터의 메모리 해제의 대상이 된다.

## 식별자 네이밍 규칙

주의점

- 대소문자는 서로 다른 것으로 구별된다.
- 변수는 의미를 명확히 표현해야 한다.
- 일반적으로 변수 함수에는 카멜 케이스, 생성자 함수와 클래스는 파스칼 케이스를 사용한다.

# ch05. 표현식과 문

여기서 나오는 용어들이 계속 쓰인다! 이 부분이 헷갈리게 되면 뒤쪽 내용을 읽는게 이해가 잘 안되고 버벅여서 다시 보는 중이다.
대충 무슨 말인지는 알겠는데 정확히 설명해봐라고 한다면 곤란하네

## 값

값은 표현식이 평가되어 생성된 결과를 말한다.

## 리터럴

리터럴은 사람이 이해할 수 있는 문자나 약속된 기호로 값을 생성하는 표기법을 말한다.
즉 js 엔진은 런타임에 리터럴을 해석해 (평가해) 값을 생성한다.

## 표현식

표현식은 값으로 평가될 수 있는 문이다. 두 가지 방법이 있는데 값을 생성하거나 기존 값을 참조하는 것이다.
먼저 리터럴은 값을 생성한다고 했으므로 (= 값으로 평가될 수 있으므로) 표현식이다.

```js
100; // 리터럴이므로 표현식이다.
var score = 50 + 50; // 50 + 50 은 평가되어 값 100을 생성하므로 표현식이다.
score; // 변수 이름(식별자)를 참조하면 변수 값으로 평가된다. 즉 100이라는 값으로 평가되므로 표현식이다.
```

또한 표현식과 값은 동치이다. 즉 값이 들어가는 자리에는 표현식으로 바꾸어 쓸 수 있도 그 반대도 성립한다.

## 문

먼저 토큰은 문법적인 의미의 최소 단위라고 할 수 있다.
여러 토큰이 모여 최소 실행 단위를 만들면 문이라고 부른다. 문이 모여서 프로그램이 된다.

## 표현식인 문과 표현식이 아닌 문

즉 모든 표현식은 문이지만, 모든 문이 표현식인 것은 아니다. (문이 더 넓은 개념)
선언문은 값으로 평가되지 않으므로 표현식이 아닌 문이며 할당문은 표현식인 문이다.

구별할 수 있는 방법은 두 가지가 있는데 변수에는 값을 할당하기 때문에 값에 할당이 가능하다면 값으로 평가되는 (=값과 동치인) 표현식인 문이다.

또한 크롬 개발자 도구에서 표현식이 아닌 문은 undefined, 표현식인 문은 평가된 값을 반환한다.

# ch06. 데이터 타입

js는 number, string, boolean, undefined, null, symbol의 여섯 가지 원시 타입과 객체 타입 총 7개의 데이터 타입을 제공한다.

## number

64비트 부동소수점 형식을 따른다. js는 숫자를 나타낼 수 있는 타입이 number 하나이므로 모든 수가 실수로 처리된다.  
또한 값을 참조시 10진수로만 해석된다. (2,8,16진수로 작성은 가능)

![6-1](img/6-1.png)

- [ ] 부동소수점에 대해서 공부하기

## string

작은 따옴표, 큰 따옴표, 백틱으로 감싸서 표현한다.

### 템플릿 리터럴

es6에서 도입된 새로운 문자열 표기법으로 몇 가지 문자열 처리 기능을 쉽게 쓸 수 있게 해주며 런타임에 일반 문자열로 변환 처리된다.

백틱``을 이용해서 표현하면 되며 표현식 삽입과 멀티라인을 지원한다.  
다음과 같이 사용할 수 있다.

![6-2](img/6-2.png)

## boolean

각각 참과 거짓을 나타내는 true와 false뿐이다.

## undefined

undefined 타입의 값은 undefined 하나 뿐이다. js 엔진이 변수를 초기화 할 때 부여하는 값으로 개발자의 의도적 사용은 권장되지 않는다고 한다.

## null

null 타입의 값은 null 하나 뿐이다. 변수에 아무 값도 없다는 것을 드러내고 싶을 때 undefined가 아닌 null이 사용된다.

## symnol

es6에서 추기된 타입으로 다른 값과 중복 되지 않는 유일무이한 값으로 객체 프로퍼티 키를 만들 때 사용된다고 한다. 뒤에 33장에서 다뤄준다고 한다.

## 객체

원시 타입과는 근본적으로 다른 타입으로 js를 구성하는 대부분이 객체 타입이다. 대충 보니 11장 이후로는 전부 객체에 관련한 이야기 들이다.

## 데이터 타입의 필요성

- 값 저장시 확보할 메모리 공간의 크기를 정하기 위해서
- 값 참조시 읽어들일 메모리 공간의 크기를 정하기 위해서
- 메모리에서 읽어들인 2진수를 어떻게 해석할지를 결정하기 위해서

## 동적 타이핑

C나 java 같은 언어는 변수 선언시 변수에 할당할 데이터 타입을 정해야 하는 정적 타입 언어이다.
js는 이와 다르게 선언만 했을 때는 타입을 가지지 않고 아는 어떤 값을 할당하느냐에 따라 변수 타입이 유동적으로 바뀌는 동적 타입언어이다.

이는 편리함과 유연한 프로그래밍을 가능케 하지만 변수 값과 타입의 변화를 추적하기가 힘들고 js 엔진에 의해 암묵적으로 타입이 바뀌는 경우도 있는 등 단점또한 존재한다. 이러한 문제를 줄이기 위해서 개발자가 할 수 있는 몇가지가 있음.

- 변수를 남발하지 않고 꼭 필요한 경우에만 쓴다.
- 변수의 스코프를 최대한 좁게 만들어야 한다
- 전역 변수를 사용하는 것을 최대한 피해야 한다.
- 변수보다는 상수를 사용한다.
- 변수는 의미를 잘 표현하도록 이름을 잘 이어야 한다.

# ch07. 연산자

연산자는 하나 이상의 표현식을 대상(피연산자)으로 하나의 값을 만든다.
피연산자와 연산자의 조합인 연산자 표현식도 표현식이므로 값으로 표현된다.

## 산술 연산자

수학적 계산을 통해 새로운 '숫자'값을 만든다.

### 이항 산술 연산자

- +, -, `*`, /, %(나머지), 5개 전부 피연산자의 값을 변경하는 부수 효과가 없다.

### 단항 산술 연산자

- ++ (피연산자 증가), -- (피연산자 감소), + (효과 없음), - (부호 반전)
- ++, -- 는 피연산자의 값을 변경하는 부수 효과가 있음.
- ++, -- 는 피연산자 앞에 위치하면 피연산자의 값을 변경한 후 다른 연산을 수행한다.
- ++, -- 는 피연산자 뒤에 위치하면 다른 연산을 수행한 후 피연산자의 값을 변경한다.

### 문자열 연결 연산자

- 는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다. 이 경우 js 엔진은 암묵적으로 피연산자의 타입을 변경하기도 한다.

![7-1](img/7-1.png)

## 할당 연산자

= 또는 '이항 산술 연산자 + ='의 6개가 있으며 우항의 평가 결과를 좌항의 변수에 할당한다.
피연산자(변수)의 값이 변하는 부수 효과가 있다. 또한 할당문은 표현식인 문으로 값으로 평가된다.

## 비교 연산자

좌항과 우항의 피연산자를 비교한 다음 같은 값인지 여부를 불리언으로 반환한다.

### ==(동등), !=(부동등)

비교 전 좌항과 우항을 암묵적으로 타입을을 일치시킨 후에 비교한다.

### ===(일치), !==(불일치)

타입 변환없이 비교하며 양측의 타입도 같고 값도 같은 경우에만 true를 반환한다.

- NaN은 자신과 일치하지 않는 유일한 값이다. NaN인지 체크는 Number.isNaN()으로 해야 한다.

## 대소 관계 비교 연산자

피연산자의 크기를 비교하여 불리언 값을 반환한다.

- > , <, >=, <=
- 책에는 없었는데 암묵적 타입 변환이 이루어질 수 있고 비교가 불가능 한 경우는 false로 처리하는 듯 하다.

![7-2](img/7-2.png)

## 삼항 조건 연산자

- 조건식 ? 조건식이 true일때 반환할 값 : 조건식이 false일 때 반환할 값

식에서 알수 있듯이 삼항 조건 연산자는 둘 중 하나의 값으로 평가되는 표현식인 문이다.  
if ... else 문과 유사한 기능이지만 if ... else 문은 표현식이 아닌 문이기 때문에 이 부분에서 차이가 있다.

## 논리 연산자

- ||(OR), && (AND), !(NOT)
- OR과 AND는 2개의 피연산자 중 하나로 평가되기 때문에 평가 결과는 불리언이 아닐 수 있다. (9.4 참조)

## 쉼표 연산자

## 그룹 연산자

- ()로 피연산자를 감싸면 해당 표현식을 제일 먼저 평가한다.

## typeof

피연산자의 타입을 문자열로 반환한다. typeof null 이 object를 반환하는 것에 주의

## 지수 연산자

# ch08. 제어문

## 블록문

코드 블록, 블록이라고도 하며 문을 중괄호로 묶은 것으로 js는 이것을 하나의 실행 단위로 취급한다.  
블록문은 자체 종결성을 가지기 때문에 끝에 세미콜론을 붙이지 않는다.

# ch09. 타입 변환과 단축 평가

## 타입 변환

### truthy

불리언 타입이 아닌 값을 불리언 타입으로 평가해야 할 때 js 엔진은 암묵적 타입 변환을 한다.  
이 때 다음의 7가지만 false로 암묵적 변환되는 falsy 값이고 나머지는 true로 변환되는 truthy값이다.

- falsy 목록 : false, undefined, null, 0, -0, NaN, ''(빈 문자열)

## 단축 평가

||와 &&는 논리 연산의 결과를 결정한 피연산자를 그대로 반환하는데 이를 단축 평가라고 한다.

![9-1](img/9-1.png)

단축 평가로 if문을 대체할 수 있다.
