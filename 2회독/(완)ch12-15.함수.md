# 12. 함수

## 함수의 정의

일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.

함수 내부로 입력을 전달받는 변수를 **매개변수**, 입력(즉 실제 받는 값)을 인수, 출력을 반환값이라고 한다. 함수는 값이며, 식별자인 함수 이름을 쓸 수 있다.

함수는 함수 정의로 생성되며, 별도로 함수 호출을 해야 실행된다.

함수는 코드의 재사용성에서 매우 유용하다.

## 함수 리터럴

js에서는 함수 또한 리터럴로 생성이 가능하다.

- function 키워드
- 함수 이름 : 식별자이므로 식별자 네이밍 규칙을 준수해야 한다. 함수 몸체 내에서만 참조할 수 있으며 생략이 가능하다.
- 매개변수 목록 : () 안에 작성하며 호출 시 지정한 인수가 **순서대로** 할당 된다. 함수 내에서 변수로 사용이 가능하며 식별자 네이밍 규칙을 준수하야 한다.
- 함수 몸체 : 호출시 일괄적으로 실행되는 문들이다.

```js
function add(x, y) {
  return x + y;
}
```

함수 리터럴은 리터럴이므로 런타임에 평가되어서 값(객체)을 생성한다.

## 함수의 정의

### 함수 선언문

함수 리터럴과 형태가 동일하나 이름을 생략할 수 없다. 함수 리터럴과 달리 **표현식이 아닌 문**으로 변수에 할당할 수 없다.

```js
function add(x, y) {
  return x + y;
}
```

그러면 함수 리터럴(은 표현식임)은 변수에 할당할 수 있는데, 같은 모양을 가진 함수 선언문은 그럴 수 없다? 그렇다면 이 두 개를 어떻게 구분하는 것인가.

js 엔진은 이러한 중의적 표현을 문맥에 따라서 해석한다. 예컨대 변수 할당이나 피연산자 등 값이 들어갈 자리에는 같은 모양이라도 함수 리터럴로, 값이 들어가는 자리가 아닌 경우에는 함수 선언문으로 해석한다.

다시 함수 선언문으로 돌아와서, 함수 선언문으로 선언한 함수는 호출할 수 있다. 헌데 함수 이름(식별자)는 함수 몸체 내에서만 참조할 수 있다고 하였는데 어떻게 외부에서 식별자를 통해 호출할 수 있는 것인가? 이것은 js 엔진이 호출을 위해 함수 이름과 같은 이름의 식별자를 암묵적으로 생성하고, 거기게 함수 객체를 할당한다. 그러니까 사실 함수 이름이 아닌 (js가 암묵적으로 생성한) 식별자로 호출한 것이다.

### 함수 표현식

함수는 객체 타입의 값이므로 평가되어 값(함수)을 생성하는 함수 리터럴을 변수에 할당하는 것이 가능하며 이러한 정의 방식을 함수 표현식이라고 한다.

```js
var add = function foo(x, y) {
  return x + y;
};
```

이 경우 함수 이름으로는 외부에서 호출이 불가능하며 함수 이름은 생략이 가능하다.

```js
var add = function (x, y) {
  return x + y;
};

add(2, 5);
```

### 호이스팅

함수 선언문은 (다른 선언문들이 그렇듯) 런타임 이전에 실행되어 함수 객체를 생성하고, 함수 이름고 같은 식별자를 암묵적으로 생성하여 거기에 생성된 함수 객체를 할당한다. 따라서 함수 선언문을 함수 호이스팅이 발생하며 함수 호출이 함수 선언문보다 코드 상의 위쪽에 있어도 실행이 가능하다.

반면 함수 표현식은 변수에 함수 리터럴을 할당하는 것이다. 함수 리터럴이 할당 된 변수는 런타임 이전에 생성되지만 undefined로 초기화 되어 있을 뿐이다. 변수에 할당되는 함수 리터럴의 평가는 **할당문이 실행되는 시점인 런타임에 이루어 지므로** 함수 객체가 생성되는 시점은 변수가 초기화된 이후이다.

따라서 함수 표현식보다 코드 위쪽에서 해당 함수를 호출하게 되면 그 시점에서는 변수는 undefined로 초기화 되어 있고 함수 객체가 생성되어 할당되기 이전이므로 undefined를 함수 호출한 셈이 되어서 타입에러가 발생한다.

정리하자면 함수 선언문은 함수 호이스팅이, 함수 표현식은 변수 호이스팅이 발생한다.

### Function 생성자 함수

빌트인 생성자 함수 Function을 new 연산자와 함께 매개변수 목록과 함수 몸체를 문자열로 전달하면서 호출하면 함수 객체가 생성되어 반환된다.

```js
var add = new Function('x', 'y', 'return x + y');
```

이 방법은 일반적이지 않고 원장되지 않는다.

### 화살표 함수

간략한 표현으로 함수를 생성할 수 있으며 항상 무기명 함수로 정의한다. ES6에서 추가되었으며 단순히 표현의 차이 뿐만 아니라 여러 기능 동작의 설계에서도 차이점이 있다. 나중에 화살표 함수 파트에서 살펴보자.

```js
const add = (x, y) => x + y;
```

## 함수 호출

함수 호출은 함수 객체를 바인딩한 식별자와 소괄호 안에 0 개 이상의 인수를 쉼표로 구분해서 호출한다.

```js
function add(x, y) {
  return x + y;
}

add(2, 5);
```

##

매개변수와 인수

인수는 함수 호출시 지정하며, 매개변수를 통해 함수 내부로 전달된다. 인수는 개수와 타입에 제한이 없다. 매개변수는 함수 몸체 내부에서 변수와 동일하게 취급된다. 변수처럼 함수 몸체 실행시 undefined로 초기화 된 후, 인수의 값으로 할당이 된다.
함수는 매개변수와 전달된 인수의 개수가 같은지 체크하지 않는다. 인수가 모자라면 남은 매개변수는 undefined로 남아있게 된다. 인수가 남으면 무시되지만 함수 내부의 arguments 객체에 저장은 되어 있다.

### 인수 확인

함수는 인수의 개수를 확인하지 않은 뿐만 아니라 매개변수의 타입을 사전에 지정할 수 없으므로 어떤 타입의 인수를 전달하여도 그대로 실행한다.  
이는 개발자의 설계 의도와는 다르게 동작할 위험성이 있으며 부적절한 호출에 의한 에러는 실제로 함수가 호출되는 런타임에 발생하게 되므로 대비가 필요하다.

해결책 몇 가지가 있다.

- 함수 몸체 내에서 if문 등으로 인수의 타입을 확인한다.
- 단축 평가를 통해 인수가 전달되지 않은 경우 기본으로 쓸 값을 설정한다.
- ES6 에서 도입된 매개변수 기본값을 사용할 수 있다.

```js
// 매개변수에 undefined를 전달하거나 매개변수를 전달하지 않았을 경우에만 작동한다.
function add(a = 0, b = 0) {
  return a + b;
}
```

### 매개변수의 개수

js는 (엔진의 물리적 한계에 다다르기 전까지는) 충분히 많은 수의 매개변수를 함수에 지정할 수 있다. 하지만 매개변수가 많아지는 것은 함수가 여러가지 일을 한다는 뜻이며 호출시 인수의 순서를 고려해야 하는 복잡함이 증가하므로 최대한 적을 수록 좋다.  
만약 3개 이상의 매개변수가 꼭 필요하다면 매개변수를 객체로 만들어 전달하는 것이 낫다.

## 반환문

함수 몸체 내에서 return 키워드와 표현식으로 이루어진 반환문으로 결과를 외부로 반환할 수 있다. 반환문이 반환하는 값은 함수 호출(표현식)의 평가 결과가 된다.

- return 문이 실행되면 함수 실행을 종료하므로 그 뒤에 오는 문은 실행되지 않는다.
- return 뒤에 아무것도 쓰지 않으면 undefined를 반환하면 반환문 자체를 생략해도 undefined를 반환한다.
- 함수 몸체 내에서만 사용이 가능하다.

## 참조에 의한 전달과 외부 상태의 변경

매개변수는 함수 몸체 내부에서 변수와 동일하게 취급되므로, 매개변수로 값을 전달하는 것은 일전에 살펴보았던 **값이 할당된 변수를 다른 변수에 할당**하는 것과 같은 방식으로 작동한다.  
따라서 함수 몸체 내에서 전달 받은 원시 값을 변경하여도 새로운 메모리 주소에 값 자체가 복사되어 전달되므로 외부의 값에는 영향을 미치지 않지만, 반면 객체를 전달 받아서 변경하면 전달해준 외부 객체의 변화가 생긴다. 이것은 코드를 복잡하게 만드는 것이므로 좋지 않다.

이러한 해결책 중 하나는 객체를 불변 객체로 만들어서 복사본을 완전히 새로 만드는 비용을 지불하고 재할당을 통해 교체하는 방법이 있다.

## 다양한 함수의 형태

### 즉시 실행 함수 (IIFE)

함수 정의돠 동시에 호출되는 함수이다. 단 한번만 호출되며 다시 호출이 불가능하다.

```js
(function () {
  var a = 3;
  var b = 5;
  return a + b;
})();
```

그룹 연산자 ()내에는 값으로 평가될 수 있어야 하므로 위에서 () 내의 문은 함수 선언문이 아니라 함수 리터럴로 해석되어 함수 객체를 생성한다. 그리로 뒤에 붙은 ()는 함수 호출 연산자로 해석되어 함수를 호출한다.

함수는 익명으로 보통 하지만 기명으로 써도 상관없다. 다만 함수 리터럴로 해석되기 때문에 함수 이름이 함수 내부에서만 식별할 수 있게 되어서 외부에서 호출은 불가능하다.

즉시 실행 함수 또한 일반 함수처럼 값을 반환하거나 인수를 전달할 수 있다.

```js
var res = (function () {
  var a = 3;
  var b = 5;
  return a + b;
})();

console.log(res); // 8

var res = (function (a, b) {
  return a + b;
})(3, 5);
```

### 재귀 함수

함수가 자기 자신을 호출하는 함수를 재귀 함수라고 한다.

```js
function factorial(n) {
  if (n <= 1) return 1;
  return n * factorial(n - 1);
}
```

재귀 함수는 함수가 무한히 호출되지 않게 반드시 탈출 조건을 만들어야 한다. 그러지 않는 경우 스택 오버플로우 에러가 발생하게 된다. 이러한 위험성 때문에 반복문보다 재귀 함수를 사용한 것이 더 이해하기 쉬울 때에만 제한적으로 사용하는 것이 좋다.

### 중첩 함수

함수 내부에 정의된 함수를 중첩 함수(내부 함수)라고 부르며 중첩 함수를 포함하는 함수를 외부 함수라고 부른다. 중첩 함수는 외부 함수 내부에서만 호출할 수 있으며, 보통 외부 함수의 기능을 돕는 헬퍼 함수의 역할을 한다.

### 콜백 함수

로직의 일부분이 같은 작업을 반복해야 하는 경우, 매번 함수를 새로 만드는 것 보다 함수의 합성을 이용하는 것이 효율적으로 문제를 해결할 수 있다.
함수의 공통 로직은 미리 정의해 두고, 변화하는 부분은 함수 외부에서 추상화해서(다른 함수로 만들어서) 공통 로직은 정의한 함수 내부로 전달한다.  
이 때 함수의 매개변수를 통해서 다른 함수의 내부로 전달되는 함수를 콜백 함수, 콜백 함수를 전달받은 함수를 고차 함수 라고 부른다.

```js
function repeat(n, f) {
  for (var i = 0; i < n; i++) {
    f(i);
  }
}
// 이 함수는 어떠한 작업을 n 번 반복한다는 로직을 가지고 있다. n 번 반복해야 하는 작업이 다양한 경우, 그때마다 일일히 함수를 만드는 것 보다 저렇게 공통된 부분을 미리 작성한 후 다른 부분을 repeat의 인자로 전달하면 된다.

var logAll = function (i) {
  console.log(i);
};
var logOdds = function (i) {
  if (i % 2) console.log(i);
};
// 서로 다른 로직을 가지는 부분을 따로 작성하였다.

repeat(5, logAll);
repeat(10, logOdds);
// 필요한 부분을 매개변수를 통하여 전달한다.
```

고차 함수는 콜백 함수를 자신의 몸체 내에서 호출하게 된며 필요에 따라서 인자를 전달한다. 따라서 콜백 함수를 호출하는 것이 아닌 고차 함수에 콜백 함수 자체를 전달해야만 한다.

전달 방법에는 2가지가 있다. 먼저 고차 함수의 매개변수 자리에 함수를 정의하는 방법이다. 매개변수 자리에는 값이 들어가는 자리 이므로 익명 함수 리터럴로 평가가 되어 전달된다.

```js
repeat(5, function (i) {
  if (i % 2) console.log(i);
}); // 인수로 직접 함수를 작성
```

아니면 위의 예제처럼 따로 함수를 작성해 두고 인자로 전달한다.

### 순수 함수

부수 효과가 없는 함수, 즉 외부 상태에 의존하지 않고 외부 상태를 변경하지도 않는 함수를 함수형 프로그래밍 패러다임에서는 **순수 함수**라고 일컫는다.  
외부 상태가 아닌 매개변수를 통해 전달된 인수에만 의존하여 값을 생성하므로, 호출될때마다 항상 같은 값을 반환한다. 또한 인수를 변경하지 않는 것이 기본이다.

또한 외부 상태를 변경하지도 않는다고 하였다.

```js
var count = 0;

// increase는 인수에만 의존하여 값을 생성하고, 외부 상태를 변경하지 않으므로 순수 함수이다.
function increase(n) {
  return ++n;
}

// 외부 상태인 count의 값에 따라서 리턴값이 변하므로 외부 상태에 의존하며, 또한 외부 상태인 count 변수의 값을 변경하는 비순수 함수이다.
function increaseCount() {
  return ++count;
}
```

위와 같은 비순수 함수는 상태 변화를 추적하기 어렵게 된다는 단점을 가지고 있다. 따라서 이런 형태의 함수는 코드를 복잡하게 하므로 지양하는 것이 좋으며 이러한 문제가 발생하지 않도록 순수 함수와 보조 함수의 조합을 통하여 부수 효과를 최대한 없애서 불변성을 지향하고 코드의 안정성을 지향하는 프로그래밍 패러다임을 함수형 프로그래밍이라고 부른다.

# 13. 스코프

모든 식별자는 자신이 선언된 위치에 의해 자신이 유효한 범위가 결정되는데, 이것을 스코프라고 한다.  
마치 함수의 매개변수는 함수 내에서만 참조할 수 있는 것처럼, 선언된 위치(함수의 매개변수)가 참조할 수 있는 범위를(함수 몸체 내부) 결정한다.

같은 이름을 가진 식별자가 여러 개 있을 경우, js 엔진은 어떤 식별자를 참조해야 할 지를 스코프를 통해서 결정하는데, 이를 식별자 결정이라고 한다.  
반대로 말하면 스코프가 다르다면 식별자의 이름을 다른 식별자와 같게 할 수 있다는 것이다.

## 종류

코드는 전역(코드의 가장 바깥 영역)과 지역(함수 내부)으로 구분되는데, 이 구분을 기준으로 선언된 위치에 따라서 유효한 범위가 결정된다.

### 전역 스코프

전역에 선언된 식별자는 전역 스코프를 가져서 어디서든지 참조할 수가 있다.

### 지역 스코프

함수 몸체 내부에 선언된 식별자는 자신이 선언된 지역과 하위 지역 스코프(중첩 함수가 생성하는 스코프)에서 유효하다.

## 스코프 체인

위의 중첩 함수의 설명처럼 함수와 마찬가지로 스코프 또한 중첩될 수 있다. 따라서 중첩 함수 스코프 - 외부 함수 스코프(지역 스코프) - 전역 스코프 같은 계층적 구조를 이루며, js 엔진은 변수를 참조할 떄 변수를 참조하는 코드가 있는 스코프부터 시작하여 상위 스코프 방향으로 이동하면서 식별자를 검색한다. 따라서 참조하는 식별자가 하위 스코프에 등록되어 있지 않을 경우 해당 스코프의 상위 스코프에서 식별자를 검색하게 되므로 상위 스코프에서 유효한 식별자는 하위 스코프에서도 사용할 수 있지만 그 반대를 성립하지 않는다.

## 함수 레벨 스코프

js의 변수 선인 키워드인 var는 다른 프로그래밍 언어와는 다르게 함수만을 지역 스코프로 인정한다. 그리고 이것은 문제점이 있다.

다음 예제를 보자. 전역에 선언된 var i = 10; 이 있고 for 문의 인덱스로 사용하는 var i = 0; 있다. 이 설계의 의도상 for 문 안의 i는 단순히 for문을 위해서 사용하는 것일 뿐인데 var가 함수만을 지역 스코프로, 즉 for 문을 지역 스코프로 인정하지 않아서 둘다 전역 변수로 선언되어 의도하지 않은 전역 변수의 재할당이 이루어지게 된다.

```js
var i = 10;

for (var i = 0; i < 5; i++) {
  console.log(i); // 0 1 2 3 4
}

console.log(i); // 5
```

이러한 문제점을 고친 것이 let, const 인데 뒤 챕터에서 다루게 된다.

## 렉시컬 스코프

js는 함수를 어디서 호출했느냐가 아닌 함수를 어디에서 정의했느냐에 따라 해당 함수의 상위 스코프를 결정한다.  
따라서 이 말은 함수의 호출 위치가 달라져도 **자신의 상위 스코프를 어딘가에 기억하고 있어야 한다** 라는 뜻이 된다. 이것은 뒤에서 그 실체를 다루게 된다.

# 14. 전역 변수의 문제점

전역 변수의 무분별한 사용은 위험하며 전역 변수의 사용은 최대한 억제되어야 한다. 그 이유와 방법을 알아보는 장이었다.

## 지역 변수의 생명 주기

지역 변수의 선언문이 실행 되는 것은 함수 호출 직후, 함수 코드 실행 전의 평가 단계에서 이루어진다. 이후 함수 코드 실행 시에 변수데 값이 할당되어 함수 종료시 지역 변수 또한 소멸되어 생명 주기가 종료 된다. 즉 지역 변수의 생명 주기는 함수의 생명 주기와 같다. (다만 클로저의 경우는 제외)

## 전역 변수의 생명 주기

전역 변수의 선언문이 실행은 명시적 호출 없이 코드 로딩이 되자마자 해석된며 함수와 달리 반환문을 사용할 수 없으므로 마지막 문이 실행되고 종료한다.

var를 전역으로 선언하면 전역 객체의 프로퍼티가 된다. 전역 객체는 해당 웹페이지를 닫을 때까지 유효하므로 var로 선언한 전역 객체 또한 그렇다.

## 전역 변수의 문제점

전역 변수는 몇 가지 문제점이 있다.

- 암묵적 결합 : 모든 코드가 전역 변수를 참조할 수 있으므로 가독성이 나빠지며 의도하지 않은 변경이 일어날 우려가 있다.
- 긴 생명 주기 : 웹페이지를 닫을 때까지 유효하므로 전역 변수의 상태를 변경할 수 있는 시간도 길며 또 메모리도 계속 차지하고 있는다.
- 스코프 체인의 종점에 존재 : 전역 변수는 스코프 체인의 종점에 존재하므로, 식별자 검색시 맨 마지막에 검색된다. 이것은 지역 변수보다 전역 변수를 검색하는데 더 과정이 오래 걸린다는 것이므로 시간또한 더 오래 걸린다.
- 네임스페이스 오염 : js는 파일이 분리되어 있어도 하나의 전역 스코프와 전역 객체를 공유한다. 따라서 다른 파일이더라도 같은 이름의 전역 변수를 선언하면 의도치 않은 결과를 가져올 수 있다.

## 억제 방법

이러한 이유 때문에 전역 변수의 사용은 최대한 억제되어야 하며 그럴 뿐만 아니라 변수의 스코프는 가능한 좁아야 한다.

반드시 필요한 경우가 아니면 전역 변수를 사용하지 말아야 한다. 그럴 수 있는 방법을 알아보자.

### 즉시 실행 함수

정의와 동시에 호출되는 즉시 실행 함수는 단 한 번만 호출되며 추후에 외부에서 호출이 불가능하다. 전체 코드를 즉시 실행 함수로 감싸게 되면 모든 변수는 즉시 실행 함수의 지역 변수가 된다.

### 네임스페이스 객체

```
네임스페이스 : 개체를 구분할 수 있는 범위를 나타내는 것
```

전역에 네임스페이스 역할을 담당할 객체를 생성하고 전역 변수 대신 해당 객체의 프로퍼티로 추가한다.

MYAPP 이라는 객체를 전역을 의미하는 범위, 따라서 MYAPP이 MYAPP 내부와 외부로 개체를 구분할 수 있는 네임스페이스가 되어서 해당 방법으로 전역 변수의 사용을 억제할 수 있다.

```js
var MYAPP = {};
MYAPP.name = 'kim';

console.log(MYAPP.name);
```

같은 페이지 내에 존재하는 라이브러리 / 서드 파티 코드와의 구분을 용이하게 하는 장점이 있으나 (내가 작성한 것은 전부 MYAPP이 앞에 이름이 붙으므로) 코드량이 늘어나고 어쨌든 MYAPP 자체가 전역 변수에 할당 되는 단점이 있다.

### 모듈 패턴

클래스를 모방한 모듈 패터으로 전역 변수 억제와 캡슐화까지 구현을 할 수 있다. 모듈 패턴은 클로저를 기반으로 작동한다.

```
캡슐화 : 프로퍼티와 메서드를 하나로 묶는 것, 특정 프로퍼티나 메서드를 감출 용도로도 사용하는데 이는 정보 은닉이라고 함.
```

```js
var counter = (function () {
  var num = 0;

  return {
    increase() {
      return ++num;
    },
    decrease() {
      return --num;
    },
  };
})();
console.log(Counter.num); // undefined
console.log(Couter.increase()); // 1
```

즉시 실행 함수는 정의와 동시에 호출되어 객체를 반환한다. 이 떄 반환되는 객체에 프로퍼티 (메서드)는 외부 접근이 가능하지만 즉시 실행 함수 내에 있고 리턴되지 않는 값 (여기서는 num)은 외부에서 접근이 불가능하다.

다만 리턴한 값 내에서 (increase, decrease)로 숨겨진 num을 조작할 수 는 있는데 이것은 메서드가 상위 스코프를 기억하고 있기 떄문이다. (클로저 참고)

### ES6 모듈

ES6부터는 파일 자체의 모듈 스코프를 제공하는 모듈 기능이 추가 되었다. 모듈 내에서 var로 선언해도 전역 변수가 아니며, 전역 객체 (window)의 프로퍼티가 되지도 않는다.

html 에서 js를 불러올 시 type="module" 를 작성하고 파일 확장자를 .mjs(권장)로 해 주면 된다. 인라인 js에서는 사용이 불가능하다.

```html
<script type="module" src="lib.mjs"></script>
```

## 15. let,const와 블록 레벨 스코프

ES6 이전에는 변수 선언은 var로만 가능했다. 이 var은 몇 가지 특징(사실은 단점이라고 할 수 있는)을 가진다.

1. 중복 선언 허용

   같은 이름의 식별자를 var로 중복 선언할 수 있다. 만약 중복 선언만 했다면 무시되고, 중복 선언과 초기화까지 했다면 값이 변경된다. 이 때 에러가 발생하지 않고, 이러한 특징은 의도치 않게 변수 값이 바뀔 수 있는 위험성이 있다.

2. 함수 레벨 스코프

   var는 함수 코드 블록만을 지역 스코프로 인정한다. 따라서 일반 코드 블록(if, for, try-catch 등등...)에서 선언한 var는 모두 전역 변수가 되며 이것은 의도치 않은 전역 변수의 사용을 초래한다.

3. 변수 호이스팅

   var는 변수 호이스팅에 의해서 선언 이전에 참조할 수 있다. (그리고 이 경우에는 언제나 undefined가 반환된다) 선언 이전에 참조할 수 있다는 것은 프로그램의 흐름상 맞지 않는다.

이런 문제점들로 인해서 ES6에서 변수를 선언할 수 있는 새로운 키워드인 let과 const가 도입되었다.

## let

let은 이러한 var의 문제점을 개선학 위해 고안되었으며 다음과 같은 특징을 가진다.

1. 중복 선언 금지

   같은 식별자를 let을 이용해 중복 선언하면 SyntaxError이 발생한다.

2. 블록 레벨 스코프

   var와 달리 모든 코드 블록 (함수, if, for, while, try-catch 등)을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다. 따라서 해당 블록 내에서 선언한 let은 지역 변수가 되며 전역에서는 참조가 불가능하다.

3. 변수 호이스팅의 변화

   기본적으로 런타임 이전에 변수 선언문이 실행되는 것은 동일하나 var와 달리 선언과 동시에 undefined로 초기화 되지 않고 초기화는 런타임인 변수 할당문의 실행 시에 초기화 후 할당이 이루어 진다. 따라서 선언 이전에 참조하면 (선언은 되었지만) 아무 값으로도 초기화가 되어 있지 않기 때문에 ReferenceError가 발생한다.

4. 전역으로 선언한 let

   전역에서 let으로 선언한 식별자는 전역 객체의 프로퍼티가 되지 않으므로 window.식별자 로 접근할 수 없다.

## const

const 도 기본적으로 let과 유사하나 조금 차이점이 있다.

1. 선언과 초기화

   let과 달리 선언과 동시에 초기화 해야 한다.

   ```js
   let foo; // 가능
   let bar = 1; // 가능
   const yes = 1; // 가능
   const no; // SyntaxError 발생
   ```

2. 재할당 금지

   const로 선언한 변수는 재할당이 금지된다. 따라서 const에 원시 값을 할당하면 재할당도 금지되고, 원시 값은 변경이 불가능 하므로 상수처럼 사용할 수 있다. 이 경우에는 식별자는 전체 대문자와 \_ 로 구분해서 명확히 나타내는 컨벤션이 있다.

   ```js
   const INTEREST_RATE = 0.03;
   let asset = 100;
   let interest = asset * INTEREST_RATE;
   ```

   만약 const로 선언한 식별자에 객체를 할당한 경우 재할당은 역시 금지되나 객체는 변경이 가능하므로 값을 바꾸거나 프로퍼티 생성, 삭제등은 여전히 가능하다. ( 다만 식별자에 할당된 참조 값이 변하지 않을 뿐) 따라서 const는 재할당을 금지하는 것이지 완전한 불변을 의미하지는 않는다.

## 결론

ES6 이상이라면 var는 사용하지 않는다. const를 사용하며 재할당이 반드시 필요하다고 생각되는 경우에는 숙고 후에 let을 사용하자.
