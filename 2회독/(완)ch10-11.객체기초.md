# 10. 객체 리터럴

## 객체 타입

객체 타입은 다양한 타입의 값을 하나의 단위로 구성한 자료구조이다. 원시 값과 달리 변경 가능한 값이다.  
객체는 키와 값의 쌍인 프로퍼티로 구성되어 있다.

다음의 예제를 보자. 객체의 프로퍼티 키는 모든 문자열 또는 심벌 값이 가능하고, 객체의 프로퍼티 값은 값으로 평가되는 모든 것이 가능하다. 함수 또한 객체이며 값으로 평가되므로 함수도 프로퍼티 값이 될 수 있는데, 이 경우에는 특별이 프로퍼티가 아닌 메서드라고 부른다.

```js
const person = {
  // 문자열을 값으로 가지는 프로퍼티
  name: 'lee',
  // 메서드
  getAge: function () {
    // 코드
  },
};
```

## 객체 리터럴

js는 객체를 생성하는 방식이 다른 언어에 비해서 많고 방법 또한 유연한데, 가장 일반적이로 편리한 방법은 객체 리터럴을 사용하는 것이다. 위의 예제처럼 객체 리터럴은 {} 내에 0개 이상의 프로퍼티 (빈 객체도 가능)를 정의하면 된다. 이것은 값으로 평가될 수 있으므로 변수에 할당되는 시점에 리터럴이 해석되 객체가 생성된다.

## 프로퍼티

객체를 구성하는 프로퍼티는 키와 값으로 이루어져 있다. 키는 모든 문자열과 심벌 값을 사용할 수 있다.

### 식별자 네이밍 규칙

문자열이 키가 되는 경우 문자열이니까 따옴표로 키를 감싸야 하지만 만약 키가 식별자 네이밍 규칙을 따르는 경우에는 따옴표를 생략할 수 있으며 이 쪽이 권장된다.

### 생성 규칙

- 문자열을 []로 묶어서 프로퍼티 키를 동적으로 생성할 수 있다.
- 문자열, 심벌이 아닌 값을 키로 설정할 경우 암묵적으로 문자열로 변환한다.
- 예약어나 빈 문자열도 키로 사용할 수 있으나 권장하지 않는다.
- 같은 이름의 키를 중복 선언하면 나중에 선언한 키로 덮어써지며 에러가 발생하지 않는다.

## 프로퍼티 접근

프로퍼티는 2가지 방식으로 접근할 수 있다.

```js
객체이름.키 // 마침표 표기법
객체이름.[키] // 대괄호 표기법
```

### 주의점

- 식별자 네이밍 규칙을 따르지 않는 경우에는 반드시 대괄호 표기법만을 사용해댜 한다.
- 또한 대괄호 표기법을 사용할 시에는 프로퍼티 키를 따옴표로 감싸야 한다. (식별자 네이밍 규칙 준수에 상관없이)
- 다만 이때 프로퍼티 키가 숫자로만 이루어진 문자열일 경우에는 따옴표를 생략할 수 있다. (숫자로 시작하면 식별자 네이밍 규칙이 위배되므로 마침표 표기법은 사용 불가능하다.)

## 프로퍼티 조작

- 이미 존재하는 프로퍼티에 값을 할당하면 값이 갱신된다.
- 존재하지 않는 프로퍼티에 값을 할당하면 값이 생성된다.
- delete 객체이름.키 로 프로퍼티를 삭제할 수 있다. 없는 경우 에러가 발생하지 않는다.

## ES6에서 추가된 기능

### 프로퍼티 축약 표현

프로퍼티 값으로 변수를 사용하는 경우, 변수 이름과 프로퍼티 키의 이름이 같은 경우에 키를 생략할 수 있다.

```js
let x = 1,
  y = 2;

const obj = { x, y }; // obj : {x: 1, y: 2}
```

### 계산된 프로퍼티 이름

문자열(또는 문자열로 변환가능한 값으로 평가되는 표현식)을 사용해 프로퍼티 키를 동적으로 생성할 수 있다. 사용할 문자열(표현식)을 []로 묶어 주어여 한며, ES6에서는 객체 리터럴 내부에서도 해당 방식으로 사용이 가능하게 바뀌었다.

```js
let i = 0;

const obj = {
  [++i]: i,
  [++i]: i,
  [++i]: i,
};
// obj = {1: 1, 2: 2, 3: 3}
```

### 메서드 축약 표현

메서드를 정의할 때 function 키워드와 : 를 생략할 수 있다. 이것은 단순한 축약이 아니라 작동 방식도 다르다는 것을 기억해 두자.

```js
// ES5
var obj = {
  sayHi: function () {
    console.log('hi');
  },
};

// ES6

const obj = {
  sayHi() {
    console.log('hi');
  },
};
```

# 11. 원시 값과 객체의 비교

## 원시 값의 불변성

원시 값은 읽기 전용인 변하지 않는 값이다. 따라서 원시 값이 할당 된 변수에 원시 값을 재할당을 하는 경우 원시 값을 바꾸는 것은 불가능 하므로 js는 새로운 메모리 공간에 새로운 원시 값을 저장한 후에 식별자에 새로운 메모리 주소를 바인딩하게 된다.

이러한 원시값의 불변성은 데이터의 신뢰성을 보증할 수 있다.

## 문자열

문자열은 js에서 원시값이다. 특이하게도 다른 원시값에 비해서 문자열은 길이에 따라서 필요한 메모리 공간이 달라짐에도 불구하고 편의를 위해 문자열을 원시 타입으로 제공한다. 따라서 문자열의 일부를 변경해도 반영되지 않는다.

## 값에 의한 전달

이번에는 원시 값을 할당한 변수를 다른 변수에 할당하는 경우를 보자.

```js
var score = 80;
var copy = score;
```

원시값이 할당된 식별자는 어떠한 메모리 주소를 가리키고 있을 것이고, 이 메모리 주소에는 할당된 원시 값 자체가 들어있다. 만약 이 변수를 다른 변수에 할당하는 경우 js는 새로운 메모리 공간에 원시 값 자체를 복사한 후 새로운 식별자(copy)에 이 새로운 메모리 공간의 주소를 바인딩한다.  
따라서 copy와 score의 값은 둘 다 80이지만 둘이 가리키는 메모리 주소는 서로 다르며, **어느 한 쪽에서 수정을 해도 다른 쪽에는 영향을 미치지 않는다.**

## 객체

객체는 원시 값과 달리 프로퍼티의 개수가 정해져 있지 않고, 어느 값이든 프로퍼티의 값이 될 수 있으며, 동적으로 추가되거나 삭제할 수 없으므로 원시 값과 다르게 객체를 위해서 할당할 메모리 값을 사전에 특정할 수가 없다.

그래서 객체는 원시 값과는 다른 방식으로 동작하도록 설계되어 있다.

## 변경 가능한 값

객체는 원시 값과 다르게 변경 가능한 값이다.  
먼저 객체를 변수에 할당하는 경우 변수가 가리키는 메모리 주소에는 객체가 들어 있는 것이 아닌 객체를 참조하는 메모리 주소가 저장되어 있고, 이 메모리 주소를 통해서 객체에 접근할 수 있다. 따라서 변수는 객체를 값으로 갖지 않고 객체를 참조하고 있을 뿐이다.

또한 객체는 복잡하고 메모리와 비용을 많이 소모하므로 객체의 값을 변경할 시에는 원시 값처럼 새로운 메모리를 확보하고 객체를 복사하는 식이 아닌, 변수가 참조하고 있는 객체를 직접 수정할 수 있게 설계하였다. 이것은 메모리 효율성과 성능의 저하를 막는데 도움이 되지만, 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 문제점이 생긴다.

## 참조에 의한 전달

이번에는 객체를 할당한 변수를 다른 변수에 할당하는 경우를 보자.

```js
var person = {
  name: 'kim',
};
var copy = person;
```

이 경우에 copy에는 무엇이 저장될까? 이 경우 js는 새로운 메모리 주소를 확보해서 거기에 원래 변수가 가리키고 있던 메모리 주소에 저장된 (객체를 가리키는) 메모리 주소, 즉 참조 값을 전달한다. 따라서 두 식별자는 서로 다른 메모리 주소를 가리키고 있으나, 그 안에 있는 값은 같은 메모리 주소로 같은 객체를 참조하고 있다.  
결국 같은 객체를 참조하고 있으므로, 어느 한 쪽에서 객체를 수정하면 다른 쪽에서도 영향을 (당연히 같은 객체를 참조하고 있으니까) 받게 된다.

사실 원시 값이나 객체나 둘 다 메모리 주소 안에 있는 '값'을 전달하는 것은 동일하나, 둘을 구별하는 의미에서 이 책에서는 이것을 참조에 의한 전달이라고 명명하였다.
