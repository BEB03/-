# 10. 객체 리터럴

## 객체 타입

객체 타입은 다양한 타입의 값을 하나의 단위로 구성한 자료구조이다. 원시 값과 달리 변경 가능한 값이다.  
객체는 키와 값의 쌍인 프로퍼티로 구성되어 있다.

다음의 예제를 보자. 객체의 프로퍼티 키는 모든 문자열 또는 심벌 값이 가능하고, 객체의 프로퍼티 값은 값으로 평가되는 모든 것이 가능하다. 함수 또한 객체이며 값으로 평가되므로 함수도 프로퍼티 값이 될 수 있는데, 이 경우에는 특별이 프로퍼티가 아닌 메서드라고 부른다.

```js
const person = {
  // 문자열을 값으로 가지는 프로퍼티
  name: 'lee',
  // 메서드
  getAge: function () {
    // 코드
  },
};
```

## 객체 리터럴

js는 객체를 생성하는 방식이 다른 언어에 비해서 많고 방법 또한 유연한데, 가장 일반적이로 편리한 방법은 객체 리터럴을 사용하는 것이다. 위의 예제처럼 객체 리터럴은 {} 내에 0개 이상의 프로퍼티 (빈 객체도 가능)를 정의하면 된다. 이것은 값으로 평가될 수 있으므로 변수에 할당되는 시점에 리터럴이 해석되 객체가 생성된다.

## 프로퍼티

객체를 구성하는 프로퍼티는 키와 값으로 이루어져 있다. 키는 모든 문자열과 심벌 값을 사용할 수 있다.

### 식별자 네이밍 규칙

문자열이 키가 되는 경우 문자열이니까 따옴표로 키를 감싸야 하지만 만약 키가 식별자 네이밍 규칙을 따르는 경우에는 따옴표를 생략할 수 있으며 이 쪽이 권장된다.

### 생성 규칙

- 문자열을 []로 묶어서 프로퍼티 키를 동적으로 생성할 수 있다.
- 문자열, 심벌이 아닌 값을 키로 설정할 경우 암묵적으로 문자열로 변환한다.
- 예약어나 빈 문자열도 키로 사용할 수 있으나 권장하지 않는다.
- 같은 이름의 키를 중복 선언하면 나중에 선언한 키로 덮어써지며 에러가 발생하지 않는다.

## 프로퍼티 접근

프로퍼티는 2가지 방식으로 접근할 수 있다.

```js
객체이름.키 // 마침표 표기법
객체이름.[키] // 대괄호 표기법
```

### 주의점

- 식별자 네이밍 규칙을 따르지 않는 경우에는 반드시 대괄호 표기법만을 사용해댜 한다.
- 또한 대괄호 표기법을 사용할 시에는 프로퍼티 키를 따옴표로 감싸야 한다. (식별자 네이밍 규칙 준수에 상관없이)
- 다만 이때 프로퍼티 키가 숫자로만 이루어진 문자열일 경우에는 따옴표를 생략할 수 있다. (숫자로 시작하면 식별자 네이밍 규칙이 위배되므로 마침표 표기법은 사용 불가능하다.)

## 프로퍼티 조작

- 이미 존재하는 프로퍼티에 값을 할당하면 값이 갱신된다.
- 존재하지 않는 프로퍼티에 값을 할당하면 값이 생성된다.
- delete 객체이름.키 로 프로퍼티를 삭제할 수 있다. 없는 경우 에러가 발생하지 않는다.

## ES6에서 추가된 기능

### 프로퍼티 축약 표현

프로퍼티 값으로 변수를 사용하는 경우, 변수 이름과 프로퍼티 키의 이름이 같은 경우에 키를 생략할 수 있다.

```js
let x = 1,
  y = 2;

const obj = { x, y }; // obj : {x: 1, y: 2}
```

### 계산된 프로퍼티 이름

문자열(또는 문자열로 변환가능한 값으로 평가되는 표현식)을 사용해 프로퍼티 키를 동적으로 생성할 수 있다. 사용할 문자열(표현식)을 []로 묶어 주어여 한며, ES6에서는 객체 리터럴 내부에서도 해당 방식으로 사용이 가능하게 바뀌었다.

```js
let i = 0;

const obj = {
  [++i]: i,
  [++i]: i,
  [++i]: i,
};
// obj = {1: 1, 2: 2, 3: 3}
```

### 메서드 축약 표현

메서드를 정의할 때 function 키워드와 : 를 생략할 수 있다. 이것은 단순한 축약이 아니라 작동 방식도 다르다는 것을 기억해 두자.

```js
// ES5
var obj = {
  sayHi: function () {
    console.log('hi');
  },
};

// ES6

const obj = {
  sayHi() {
    console.log('hi');
  },
};
```
