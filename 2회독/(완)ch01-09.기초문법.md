# 01. 프로그래밍

프로그래밍은 문제 해결을 위해 컴퓨터에게 정확하게 요구사항을 설명하는 작업이다. 컴퓨터는 0과 1만 구분할 수 있으므로 우리의 일반 사고 방식과 다르게 동작하며 컴퓨터의 관점에서 문제를 사고할 필요가 있다.

## 프로그래밍 언어

위와 같은 컴퓨터 관점의 사고로 문제 해결 방법을 고안했다면 이를 컴퓨터에게 전달해야 한다. 컴퓨터가 실행하기 때문에, 컴퓨터가 이해할 수 있는 기계어로 전달해야 한다. 하지만 기계어로 전달하는 작업은 매우 어렵기 때문에, 보통은 사람이 이해할 수 있는 구문(문법)으로 구성된 프로그래밍 언어를 사용해 프로그램을 작성한 후, 이것을 기계어로 번역하는 일종의 번역기를 사용하는 것이다. 이 번역기를 **컴파일러** 또는 **인터프리터**라고 부른다.

이런 방식으로 작동되는 프로그래밍 언어는 구문과 의미의 조합으로 표현된다.

## 구문과 의미

컴퓨팅 사고를 통한 문제 해결 방법은 프로그래밍 언어의 문법을 사용해 표현한다. 이 과정을 통해 작성된 코드는 프로그래밍 언어의 문법에 부합해야 할 뿐 아니라 수행하고자 하는 바를 정확히 수행해서 문제를 해결하기 위해서 의미적으로도 옳게 작성되어야 한다.

# 02. 자바스크립트

자바스크립트는 웹페이지의 보조적인 기능 수행을 위해서 브라우저에서 동작하는 경량 프로그래밍 언어로 만들어졌으며 1995년 넷스케이프 커뮤니케이션즈의 브렌던 아이크가 개발하였다.

헌데 마이크로소프트가 자바스크립트의 파생 버전인 Jscript 를 인터넷 익스플로러에 탑재하였다. 헌데 자바스크립트와 Jscript는 자사 브라우저의 시장 점유율을 높이기 위해서 경쟁적으로 기능을 추가하는 탓에 호환이 완벽하지 않아서 브라우저에 따라서 웹페이지가 정상적으로 동작하지 않는 **크로스 브라우징 이슈**가 발생하기 시작했고, 이 문제를 해결하기가 너무 어려웠다.

이제 표준화의 필요성을 느낀 넷스케이프가 컴퓨터 시스템 표준을 관리하는 비영리 기구인 ECMA 인터내셔널에 자바스크립트의 표준화를 요청하여, 1997년 7월 ECMA-262라고 불리는 자바스크립트 초반이 완성되었고, 자바스크립틑 ECMAScript 로 명명되었다. 이후 계속된 업그레이드를 거쳐 왔고, 특히 ECMAScript2015, 통칭 ES6 에서 범용 프로그래밍 언어로 동작하기 위한 기능들을 대거 도입하는 큰 변화가 있었다.

22/08/22 현재 ECMAScript 2022 (ES13) 까지 나왔다.

## js의 역사

js는 처음에는 단순히 웹페이지를 보조하는 역할만을 수행하였고, js를 탑재한 브라우저는 단순히 html과 css를 렌더링 하는 수준의 작업만 하였다.

1999년, js를 이용해 서버와 브라우저가 비동기 방식으로 데이터를 교환할 수 있는 Ajax (Asynchronous JavaScript and XML) 가 XMLHttpRequest 라는 이름으로 등장하였다. 서버로부터 필요한 부분만 데이터를 전송받아 한정적으로 렌더링을 하는 방식으로, 웹 브라우저에서도 데스크톱 애플리케이션 처럼 부드러운 화면 전환과 빠른 성능을 기대할 수 있게 되어서 이전의 패러다임을 바꾸었으며 2005년 구글이 이 방식을 도입한 구글 맵스를 성공적으로 선보이게 되었다.

2006 년에는 DOM을 쉽게 제어할 수 있는 jQuery가 등장하였다.

js의 가능성을 확인하여서 js 로 웹 애플리케이션을 만드려는 시도가 많아졌고, 이에 다라서 더욱 빠른 js 엔진의 필요성이 대두되었고, 구글에서 빠른 성능을 가진 2008년 V8 js 엔진을 선보이면서 기존의 많은 웹 서버 작업들이 클라이언트로 이동하는 계기가 되었다.

2009년에느느 V8 js 엔진을 기반으로 만들어진 js 런타임 환경 Node.js 가 공개되었다. 이로써 브라우저 이외의 환경에서도 js를 사용할 수 있게 되었으며, 특히 서버 사이드 애플리케이션 개발에 많이 쓰이고 있으며 이외에도 모바일, 데스크톱, 머신러닝, 로보틱스 등 다양한 환경에서 사용되는 프로그래밍 언어로서 크로스 플랫폼을 위한 중요한 언어로 주목받고 있다.

js의 성능이 좋아짐에 따라, 개발 규모와 복잡도도 상승하였고, 변경에 유연하고 확장하기 쉬운 애플리케이션 구축을 위하여 Single Page Application, SPA 가 대중화 되었고 앵귤러, 리액트, 뷰 등 다양한 프레임워크 / 라이브러리 또한 인기를 끌게 되었다.

## ECMAScript

ECMAScript 는 js 표준 사양인 ECMA-262를 말하여 여기에는 js의 핵심 문법이 규정되어 있따. 각 브라우저 제조사는 이것을 기준으로 내장되는 js 엔진을 구현한다. 우리가 js라고 부르는 것은 ECMAScript 사양에 따른 프로그래밍 언어의 기능과, 브라우저가 별도 제공하는 Web API (DOM, XMLHttpRequest, Fetch 등...) 를 아우르는 개념이다. 다만 Web API는 ECMA가 아닌 W3C에서 관리한다.

## js의 특징

js는 웹 브라우저에서 동작하는 유일한 프로그래밍 언어로, 기존의 많은 언어에서 영향을 받았다.

js는 개발자가 컴파일 과정을 수행하지 않는 인터프리터 언어이며, 명령형, 함수형, 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어이다.

# 03. js 개발 환경과 실행 방법

모든 브라우저는 js 엔진을 내장하고 있다. 브라우저의 js 엔진은 ECMA에 규정된 기능과 Web API 를 제공한다. 그런데 Web API는 브라우저에서 별도 제공하는 것으로 js 런타임 환경인 Node.js 에서는 제공되지 않는다. Node.js 도 ECMA에 규정된 기능은 공통으로 제공하므로 기본적으로 브라우저에서 작동하는 코드는 Node.js에서도 작동하지만 Web API는 브라우저 고유의 기능이므로 제공하지 않는다. 하지만 Node.js 는 그 용도에 맞게 고유의 호스트 API를 제공하며 이것은 브라우저에서 호환되지 않는다.

## js 실행

- 브라우저에서 실행 가능하다. 예컨대 크롬 브라우저에서는 개발자 도구의 콘솔에서 js 코드를 REPL 환경으로 사용할 수 있다.
- 또한 브라우저에서 html 파일을 로드하면 로드된 html 파일에 포함된 js 코드를 브라우저가 실행한다.
- Node.js 에서는 터미널을 통하여 REPL을 지원한다.
- vscode 등의 텍스트 에디터로 작성한 js 파일을 Node.js 가 실행할 수 있다.

# 04. 변수

변수는 하나의 값을 저장하기 위한 메모리 공간 그 자체 또는 그 메모리 공간을 식별하기 위한 이름을 말한다. 값의 위치를 가리키는 이름이며, 기본적으로 하나의 값을 저장하나 배열이나 객체같은 자료구조를 이용하여 여러 개의 값을 그룹화해서 하나처럼 저장할 수도 있다.

```js
var result = 10 + 20;
```

값을 식별하는 고유한 이름을 변수 이름(result), 그 변수에 저장된 값(30)을 변수 값이라고 한다.  
변수에 값을 저장하는 행위를 **할당**이라고 하고, 저장된 값을 읽어들이는 것을 **참조**라고 한다.

## 식별자

변수 이름을 식별자라고도 한다. 식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름으로, 식별자는 메모리 주소를 기억하고 있으며, 그 메모리 주소에는 (변수에 할당한) 값이 저장되어 있다. 변수 뿐만 아니라 js에서 메모리 상에 존재하는 어떤 값을 구별할 수 있는 모든 이름을 식별자라고 칭하므로 변수, 함수, 클래스 등의 이름은 전부 식별자이다.

## 변수 선언

변수를 사용하기 위해서는 반드시 변수 선언을 먼저 해야한다. 선언하지 않은 식별자에 접근하면 ReferenceError 가 발생한다.

변수 선언이란 변수를 생성하는 것을 말한다. 이를 위해서 값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보한 메모리 공간을 연결(바인딩)하는 절차를 말한다. 이 확보된 메모리 공간은 해제 이전까지는 다른 용도로 사용이 불가능하므로 안전하게 변수를 사용할 수 있다.

변수 선언은 var, let, const 키워드 뒤에 변수 이름을 적어서 사용한다.

```js
var score;
```

이 코드가 실행되면 먼저 변수 이름을 실행 컨텍스트에 등록하여서 변수 선언 단계를 거친다. 변수가 선언된 뒤, js 엔진은 확보한 메모리 공간에 쓰레기 값이 남아있을 경우에 문제가 되므로 undefined 라는 값을 암묵적으로 할당한다. 아직 변수에 값을 할당하지 않았으므로 score 가 가리키는 메모리 주소에 저장된 값은 undefined 이다.

## 호이스팅

js 는 변수 선언을 코드가 순차적으로 실행되는 시점인 **런타임**이전에 실행시키기 떄문에, 변수 선언의 위치에 상관없이 소스코드가 실행되는 시점에는 변수 선언과 초기화 단계를 마친 상태이고, 따라서 코드 상 선언보다 위쪽에 참조를 하여도 참조가 가능하며 undefined를 반환한다. (let, const는 그렇지 않다. 나중에 보자)

이처럼 변수 선언문이 마치 코드의 맨 위로 끌어올려진 것처럼 동작하는 js 고유의 특징을 호이스팅이라고 한다.

js의 모든 식별자는 런타임 이전에 선언 되므로 모든 식별자는 호이스팅된다.

## 값의 할당

변수에 값을 저장하는 행위를 할당이라고 한다고 했다.

```js
var score;
score = 80;

// 선언과 할당을 하나의 문으로 표현
var score = 80;
```

우측에 좌측에 변수, 그 다음 = 를 쓰고 오른쪽에 할당하려는 값을 적어주면 된다. 주의할 점은 변수 선언문은 런타임 이전에 실행되나 변수 할당은 런타임에 이루어진다. 이것은 선언과 할당을 하나의 문으로 쓴 경우에도 마찬가지이다. 이 경우에도 js 엔진은 선언과 할당을 분리해서 진행한다.

## 재할당

이미 값이 할당되어 있는 변수에 새로운 값을 다시 할당하는 것을 **재할당**이라고 한다. var는 변수의 재할당이 가능한 키워드이다.

재할당을 하는 경우 식별자가 참조하고 있던 메모리 주소의 값을 바꾸는 것이 아닌 새로운 메모리를 확보한 후 재할당 값을 저장하고 식별자와 새로운 메모리 주소를 바인딩하는 식으로 이루어진다. 더 이상 참조되고 있지 않는 메모리 주소의 값은 가바지 컬렉터에 의해서 해지된다. (이 부분은 엔진이 자동으로 수행한다)

## 식별자 네이밍 규칙

js의 모든 식별자는 식별자 네이밍 규칙을 준수해야 한다.

- 특수문자를 제외한 문자, 숫자, \_, $ 를 포함할 수 있다.
- 단 이 중 숫자로는 시작할 수 없다. 즉, (특수문자를 제외한) 문자, \_, $ 중 하나로 시작한다.
- 예약어는 식별자로 사용할 수 없다.

```
예약어 : 프로그래밍 언어에서 사용하고 (또는 할 예정인) 있는 단어를 말한다. 예컨대 아까 변수 선언때 사용한 var 또한 예약어이다.
```

식별자 네이밍 규칙 이외에도 변수 선언시 몇 가지 고려해야 할 점들이 있다.

- 유니코드 문자가 허용되어 한글, 일본어도 가능하지만 **권장하지 않는다.**
- 하나의 변수 선언 키워드에 , 로 이름을 구분하여 여러 개를 한 번에 선언할 수 있으나 **권장하지 않는다.**
- 식별자는 대소문자를 **구별**한다.
- 변수 이름은 변수의 존재 목적을 쉽게 할 수 있도록 의미를 명확하게 표현해야 한다.

### 네이밍 컨벤션

네이밍 컨벤션은 여러 개의 영단어로 이루어진 식별자를 만들 때 가독성 좋게 구분하기 위해 만든 명명 규칙이다.

```js
// 카멜 케이스 : 두 번째 단어부터 첫 글자를 대문자로 한다.
var firstName;

// 스네이크 케이스 : 두 번째 단어부터 단어 시작에 _ 를 붙인다.
var first_name;

// 파스칼 케이스 : 모든 단어의 첫 글자를 대문자로 한다.
var FirstName;

// 헝가리언 케이스 : 접두어로 자료형을 붙인다. js에서는 DOM 노드를 다룰 때 이렇게 한다.
var strFirstName;
var $elem;
```

js에서는 일반 변수 / 함수의 이름은 카멜 케이스, 생성자 함수 / 클래스는 파스칼 케이스를 사용한다. 따라서 그것을 따르는 게 좋다.

# 05. 표현식과 문

## 값

값은 식이 평가되어 생성된 **결과**를 말한다.

4장에서 보았듯 변수에는 **하나의 값**이 할당된다. 따라서 다음 예제에서 변수에 할앋되는 것은 10 + 20 이 아닌 해당 식이 평가되어 생성된 결과인 값, 30이 할당된다.

```js
var score = 10 + 20;
```

## 리터럴

리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 **값을 생성하는** 표기법을 말한다. js 엔진은 **런타임에 리터럴을 평가해 값을 생성한다.**

```js
// 다양한 리터럴들, 따라서 js 엔진은 다음 것들과 같은 표기법을 만나면 값을 생성한다.
100
10.5
0x41
'string'
true
null
undefined
{}
[]
function () {}
...
```

## 표현식

표현식은 값으로 평가될 수 있는 문이다. 다시 말하면 식을 해석해서 값을 생성하거나 참조하는 문이다. 앞에서 본 **리터럴은 해석되어 값을 생성하므로 표현식이다.**

다음의 코드에서 10 + 20 은 해석되어 값 30을 만드므로 표현식이다.

```js
var score = 10 + 20;
```

변수 식별자를 참조하면 변수 값으로 평가된다. 값으로 평가 되므로 표현식이다.

```js
score;
```

표현식과 표현식이 평가된 값은 동치이다. 따라서 값이 위치하는 자리에는 표현식도 들어갈 수 있으며 표현식이 들어가는 자리에는 값도 들어갈 수 있다.  
예컨대, 산술 연산자 + 는 좌항과 우항에 하나 씩 두 개의 숫자 값이 필요하다.

숫자 값으로 표현되는 평가식은 숫자 값이 들어가는 자리게 들어갈 수 있다.

```js
var x = 5;

x + 3; // x 는 숫자값 5로 표현된다.
```

## 문

문은 프로그램을 구성하는 기본 단위이자 최소 실행단위다.

문은 여러 토큰으로 구성된다. 토큰은 문법적 의미를 가지를 최소한의 기본 요소를 의미한다. 문은 컴퓨터에게 명령을 내리는 역할을 하며 선언문, 할당문, 조건문, 반복문 등이 있다.

## 세미콜론

; 는 문의 종료를 나타낸다. 즉 ; 가 끝나는 곳 까지가 하나의 실행단위를 의미한다. 문을 끝내려면 ;을 붙여야 하지만, 0개 이상의 문을 묶은 코드 블록은 자체 종결성을 가지기 때문에 {} 뒤에는 ; 를 붙이지 않는다.

js 엔진은 문의 끝이라고 판단되는 곳에 ; 를 알아서 붙이므로 개발자가 직접 ; 를 쓰지 않아도 상관은 없다.

## 표현식인 문과 표현식이 아닌 문

```js
// 표현식이 아닌 문
var x;

// 표현식인 문
x = 1;
```

따라서 문에는 표현식인 문과 표현식이 아닌 문이 있다. 표현식인 문은 표현식이므로 값으로 평가되며, 표현식이 아닌 문은 값으로 평가되지 않는다.

이 둘을 구분할 수 있는 좋은 방법은 변수에 할당해 보는 것이다. 변수에는 값을 할당하고 값으로 평가되는 표현식과 해당 값은 동치이므로, 표현식인 문은 변수에 할당이 가능하며 표현식이 아닌 문은 변수에 할당이 불가능하다.

또한 크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 undefined, 표현식인 문을 실행하면 평가된 값을 반환한다.

# 06. 데이터 타입

js는 7개의 데이터 타입을 제공한다.

## 숫자 타입

js는 하나의 숫자 타입만을 제공하며 모든 수를 실수로 처리한다. 또란 모든 수를 10진수로 처리한다.

따라서 정수 표시도 사실은 실수로 처리되며, 2,8,16 의 값을 생성할 수 있는 리터럴은 존재하나 이들의 값을 참조하면 10진수로 해석된다.

추가로 무한대를 나타내는 (-)Infinity, 산술 연산이 불가능함을 나타내는 NaN 을 **숫자 타입으로** 제공한다.

## 문자열

js의 문자열은 '', "", `` 중 하나로 텍스트를 감싸서 만든다.

이중 백틱 `` 은 ES6에서 편의를 위해서 도입된 새로운 문자열 표기법으로 다음과 같은 기능을 제공한다.

### 멀티라인 문자열

일반 문자열 내에서는 개행이 허용되지 않아서 공백 표현을 위해서는 \ 로 시작하는 이스케이프 시퀀스를 사용해댜 한다. `` 내에서는 줄바꿈과 모든 공백이 작성한 대로 적용된다.

```js
var blank = `줄
바꿈과
    공백이
가능하다.`;
```

### 표현식 삽입

`` 내에서 ${} 인에 표현식을 넣으면 표현식의 평가 결과(가 문자열이 아닌 경우에는 강제 변환)가 출력된다.

```js
var score = 100;
console.log(`점수는 ${score}점 입니다`); // 점수는 100점 입니다.
```

## 불리언

참, 거짓을 나타내는 논리값 true, false 2개뿐이다.

## undefined

undefined 타입의 값은 undefined 뿐이다. 이 값은 js 엔진이 변수를 초기화할 때 암묵적으로 할당하는 값으로 이렇게 함으로써 개발자는 변수에 아직 값을 할당하지 않았다는 것을 알아차릴 수 있다.

undefined는 이렇게 js 엔진이 특정 의도를 가지고 사용하는 타입으로 개발자가 '값이 없음'을 나타내고 싶을 때에는 undefined가 아니라 null을 사용한다.

## null

null 타입의 값은 null 뿐이다. 이 타입은 변수에 값이 없음을 의도적으로 명시하고 싶을 떄 사용한다.

## symbol

심벌 타입은 나머지 원시 타입과는 다르게 리터럴이 아닌 Symbol 함수 호출로 만들어지며 객체 내에서 중복되지 않는 프로퍼티 키를 만들 때 유용하게 사용된다.

## 객체 타입

js 에서 대부분을 차지하고 있는 것이 이 객체 타입의 객체이며 나머지 타입인 원시 값과는 근본적으로 다르다. 이에 대해서는 뒤에서 다룬다.

## 데이터 타입의 필요성

그러면 왜 이렇게 데이터 타입을 서로 나누어 늫은 것인가?

먼저 데이터 타입마다 필요한 메모리 공간의 크기가 다르다. 따라서 얼만큼의 메모리 공간을 확보할 것인지를 사전에 정할 필요가 있고, 또 나중에 변수를 참조할 때 그 변수에 저장된 값의 타입이 무엇인지에 따라서 어디까지 메모리 주소를 불러들여야 할 것인가를 결정할 수가 있다.

또한 값을 불러온 이후의 2진수를 해석할 떄에도 필요하다. 컴퓨터는 모든 데이터를 2진수로 저장하므로 그것을 어떻게 해석하느냐에 따라서 값이 달라진다. 따라서 값이 무슨 데이터 타입을 가지고 있는 지를 알고 있어야만 적절한 해석이 가능히다.

## 동적 타이핑

C언어 같은 경우는 변수 선언 시에 해당 변수에 할당할 수 있는 값의 타입을 미리 선언하고, 컴파일 시점에 선언한 값의 타입을 할당하였는지를 검사해 일치하지 않는다면 에러를 발생시킨다. 이러한 타입의 언어를 **정적 타입 언어**라고 한다.

반면 js는 변수에 어떤 타입의 값이든 할당할 수가 있으며 또 언제든지 자유롭게 변경할 수 있다. 즉 js의 변수는 선언이 아닌 할당에 의해서 타입이 결정된다. 이러한 언어를 **동적 타입 언어**라고 한다.

### 동적 타이핑 언어

이러한 js의 특징은 편리함과 자유로움을 가져다 주지만 그 반대급부로 변수 값의 추적이 어렵고, 특히 js의 암묵적 타입 변환으로 인해서 예상치 못한 문제가 발생할 수 있는 등 신뢰성이 떨어지는 단점이 있다.

이러한 문제를 최대한 회피하기 위해서 다음과 같은 사항들을 지키는 것이 좋다.

- 변수는 꼭 필요한 경우에만 사용한다.
- 변수의 스코프를 최대한 좁게 만들어서 부작용을 막는다.
- 전역 변수의 사용은 최대한 피한다.
- 변수보다는 상수를 사용한다.
- 변수 이름을 변수의 목적을 파악하기 쉽게 작성한다.

# 07. 연산자

연산자는 하나 이상의 표현식(피연산자)을 대상으로 연산을 수행하여 **값을 만든다.**

표현식의 피연산자 자리에는 값(으로 평가되는 표현식)이 들어가야 하며 피연산자와 연산자의 조합으로 이루어진 **연산자 표현식 또한** 값으로 평가되는 문인 **표현식**이다.

## 산술 연산자

### 이항 산술 연산자

2개의 피연산자를 연산하여 숫자 값을 만든다. 사칙연산과 나머지 연산의 +, -, \*, /, % 5개가 있다.

### 단항 산술 연산자

1개의 피연산자를 연산하여 숫자 값을 만든다. 증가 ++, 감소 --, 부호 반전 - 이 있다.

++, -- 는 피연산자의 값을 변경하는 부수 효과가 있다. 따라서 ++, -- 의 피연산자로 쓰면 값이 변경되어 암묵적 할당이 이루어진다.

++, -- 는 피연산자의 앞에 쓰이면 값을 변경한 후 할당하며, 뒤에 쓰이면 할당 후 값을 변경한다.

### 문자열 연결 연산자

- 사용시 피연산자가 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다. 이 때 피연산자 중 문자열이 아닌 것이 있을 경우 암묵적으로 타입 변환이 이루어진다.

## 할당 연산자

우항에 있는 피연산자의 평가 결과를 좌항에 할당한다. = 과 = 에 이항 산술 연산자를 합친 총 6개가 있다.

```js
var x = 10;
x += 5;
console.log(x); // 15
```

할당문은 표현식인 문으로 **할당된 값으로 평가된다.** 예컨대 위 예제의 2번째 줄의 할당문은 15 라는 값으로 평가된다.

## 비교 연산자

좌항과 우항의 피연산자가 같은 값으로 평가되는지 여부를 불리언으로 반환한다.

== 는 값이 같다면 true, === 는 좀 더 엄격하게 값과 타입까지 같아야 true 이다.
부정은 !=, !== 으로 사용한다.

== 과 != 는 암묵적 타입 변환을 하여서 타입을 일치시킨 후 비교를 진행하기 때문에 그렇다. 이것은 예측하지 못하는 결과를 만들어 내는 경우가 있어서 === 와 !== 의 사용이 권장된다.

- 주의점
  - 0 과 -0 은 같은 것으로 (==와 ===의 연산 결과가 true로) 평가된다.
  - NaN 은 자신과 일치하지 않는 유일한 값이다.

```
이 문제를 해결하는 Object.is 메서드가 있다. 기본적으로 인수 두개를 받아서 === 와 동일하게 동작하나 -0 과 +0 을 다른 값으로, NaN 을 Nan과 같은 값으로 평가한다.
```

### 대소 관계 비교 연산자

피연산자의 크기를 비교하여 불리언 값을 비교한다. 수학에서의 >, <, >=, <= 와 같다.

## 삼항 조건 연산자

조건식의 평가 결과에 따라 다른 값을 반환하는 표현식으로, 다음과 같이 사용한다.

```
조건식 ? 조건식이 true 일 때 반환할 값 : 조건식이 false 일 때 반환할 값
```

삼항 조건 연산자 표현식은 조건문이다. 따라서 if ... else 문과 대부분의 경우 바꾸어 쓸 수 있다.

```js
// 삼항 조건 연산자
var x = 2;

var result = x % 2 ? '홀수' : '짝수';

// if ... else 문
var x = 2,
  result;

if (x % 2) result = '홀수';
else results = '짝수';
```

하지만 if ... else 문은 표현식이 아닌 문이고 삼항 조건 연산자 표현식은 반환한 값으로 평가되는 표현식이 문이다. 따라서 if ... else 문과 다르게 삼항 조건 연산자 표현식은 값의 자리에 들어갈 수 있다.

## 논리 연산자

우항과 좌항의 피연산자를 논리 연산한 결과를 반환한다.

and 연산인 ||, or 연산인 &&, not 연산인 ! 가 있다.

## 쉼표 연산자

, 는 왼쪽 피연산자부터 차례때로 평가하고 마지막 피연산자의 평가 결과를 반환한ㄷ.

```js
var x, y, z;
(x = 1), (y = 2), (z = 3); // 3
```

## 그룹 연산자

() 로 피연산자를 감싸는 그룹 연산자는 자신의 피연산자인 표현식을 가장 먼저 평가한다. 또한 모든 연산자 중에 가장 먼저 실행된다.

## typeof

피연산자의 테이터 타입을 문자열로 변환한다.

기본적으로 원시 타입 6가지와 객체에 맞추어 반환되나 null은 null 타입이지만 object로, 함수는 Object 타입이지만 Function 으로 반환된다.

피연산자의 값이 null 인지 확인하고 싶다면 === 를 사용하자.

## 지수 연산자

\*\*로 표현하며 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭제곱한 숫자 값을 반환한다.  
음수를 밑으로 사용하고 싶은 경우 좌항의 피연산자를 () 로 감싸자.

## 부수 효과

대부분의 연산자는 단순히 값을 반환할 뿐 다른 코드에는 영향을 주지 않지많, 할당 연산자, 증가(감소) 연산자, 객체의 프로퍼티를 삭제하는 delete 연산자는 다른 코드에 영향을 주는 부수 효과가 있다.

## 연산자 우선순위

모든 연산자는 우선순위가 있다. 이를 다 익히는 것은 번거롭고 실수할 확률이 있으므로 가장 우선순위가 높은 그룹 연산자 () 를 사용하여 필요한 우선순위를 조정하는 것이 좋다.

# 08. 제어문

조건에 따라 코드 블록을 실행하거나 반복 실행할 때 사용한다. 예컨대 이전에 살펴본 삼항 조건 연산자 표현식은 조건에 따라서 코드 블록을 실행하므로 제어문이다. 기본적으로 제어문은 위에서 아래로 흐르는 코드의 실행 순서를 혼란스럽게 하므로 가독성이 좋지 않게 만드는 요인이 된다/

따라서 js에서는 함수형 프로그래밍 기법을 사용한 배열 고차함수를 통하여 제어문이 하는 기능을 구현하려고 한다.

## 블록문

블록문은 0개 이상의 문을 중괄호로 묶은 것으로 , {} 안에 문을 기술하며 자체 종결성을 가지므로 ; 를 붙이지 않는다.

```js
// 예시
{
  var x = 10;
}
if (x > 5) {
  x++;
}
function pow(x) {
  return x ** x;
}
```

## 조건문

조건문은 주어진 조건식의 평가 결과에 따라서 코드 블록의 실행 여부를 결정한다.

### if ... else

js 에서 제공하는 첫 번째 조건문은 if ... else 문이다. 조건식의 평가 결과가 true인 경우 if 문의 코드 블록, false 일 경우 else 문의 코드 블록이 실행된다. 만약 조건식의 평가 결과가 불리언 타입의 값이 아닌 경우 js 엔진이 암묵적으로 불리언 값으로 변경한다.

```js
if (조건식) {
  // true 인 경우
} else {
  // false 인 경우
}
```

조건식을 추가하고 싶은 경우 else if 문을 사용한다.

```js
if (조건식1) {
  // 조건식 1이 true 인 경우
} else if (조건식2) {
  // 조건식 1이 false 이며 조건식 2가 true 인경우
} else {
  // 둘다 false 인경우
}
```

몇 가지 문법적 옵션들을 소개한다.

- else, else if 는 옵션으로 사용하지 않아도 된다. else if 만 여러 번 사용할 수 있다.
- 코드 블록 내의 문이 하나라면 {} 를 생략할 수 있다.
- 대부분의 경우 삼항 조건 연산자 표현식으로 바꾸어 쓸 수 있다.

### switch

주어진 조건식을 평가하여 그 값과 일치하는 표현식을 갖는 case 문을 실행 시킨다. 만약 일치하는 경우가 있다면 default 문으로 이동한다.

```js
switch (표현식) {
  case 표현식1:
    switch 문의 표현식과 표현식1이 일치할 경우 실행;
    break;
  case 표현식2:
    switch 문의 표현식과 표현식1이 일치할 경우 실행;
    break;
  default;
    switch 문의 표현식과 일치하는 case문이 없을 때 실행되는 문;
}
```

default는 옵션이며 각 switch 문에 코드 탈출을 한느 문인 break를 걸어주지 않으면 다음 case로 넘어가니 주의하자.

## 반복문

반복문은 조건식의 평가 결과가 true 인 경우에 코드 블록을 실행한다. 이후 조건식의 평가 결과가 false 일 때까지 계속 조건식의 평가과 코드 블록 실행을 반복한다.

### for

보통 다음과 같은 형태로 쓰인다.

```
for (변수 선언문 또는 할당문; 조건식; 증감식) {
  조건식이 참일 경우 반복 실행할 문;
}
```

다음의 예시를 보자.

```js
for (var i = 0; i < 2; i++) {
  console.log(i);
}
// 0 1
```

실행 순서는 변수 선언(할당), 조건식 확인, (조건식이 true일 경우) 코드 블록 실행, 증감식 실행, 조건식 확인 ... 이 반복된다.

1. var i = 0 로 변수 선언 및 할당
2. i < 2 이므로 조건식 평과 결과 true
3. true 이므로 코드 블록 내의 문 console.log(i) 실행
4. i++ 실행
5. i < 2 이므로 조건식 평과 결과 true
6. true 이므로 console.log(i) 실행
7. i++ 실행
8. i < 2 가 아니므로 조건식 평과 결과 false 이 되어 종료

- 증감식을 사용하므로 특정 변수를 줄여가면서 역순으로 for문을 사용할 수 있다.
- for 문의 () 안의 식은 모두 옵션이믈 사용하지 않을 수 있지만 아무것도 선언하지 않으면 무한루프가 된다.
- for 문 안에 for 문을 사용하는 것이 가능하다.

### while

조건식의 평가 결과가 (불리언이 아닌 경우 강제 변환하여) true 이면 코드 블록을 실행하며 false 이면 종료한다.. 주로 for 문과 달리 반복 횟수가 명확하지 않을 때 사용한다.

```js
var count = 0;

while (count < 3) {
  console.log(count);
  count++;
}
```

조건식의 평가 결과가 항상 참이면 무한루프가 된다. while 내에 if 를 작성하여 break를 코드 블록을 탈출한다.

### do .. while

while과 비슷하지만 조건식 평가 후 코드 블록을 실행하는 것이 아닌 코드 블록을 실행하고 조건식을 평가한다. 따라서 do .. while 의 코드 블록을 적어도 한 번 이상 실행된다.

## break

레이블 문, 반복문, switch 문에서 사용되어 코드 블록을 탈출한다.

```js
// 레이블 문
레이블 식별자가 붙은 문을 말한다.
foo: console.log('foo');
```

레이블 식별자는 특히 이중 for 문의 내부 for 문에서 완전히 밖으로 탈출할 때 사용한다. 그냥 break 를 사용하면 내부 for문에서 외부 for문으로 이동하기 때문이다.

```js
outer : for () {
  for () {
    if () break outer;
  }
}
```

## continue

continue 문은 반복문의 코드 블록 실행을 continue가 실행된 시점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동시킨다.

```js
var string = 'hello world';
var count = 0;
// 그냥 코딩
for (var i = 0; i < string.length; i++) {
  if (string[i] === 'e') {
    count++;
    console.log(string[i]);
  }
}

// continue 사용
for (var i = 0; i < string.length; i++) {
  if (string[i] !== 'e') continue; // 이번엔 같지 않은 경우에 continue 를 실행한다!
  count++;
  console.log(string[i]);
}
```

continue 를 사용시 for 문 내에서 if 문을 사용하고 if 문의 코드 블록이 여러 줄이라면 들여쓰기를 한 칸 없앨 수 있는 장점이 있다.

# 09. 타입 변환과 단축 평가

js의 모든값은 타입이 있다. 이는 개발자의 의도에 의해서 다른 타입으로 변경될 수 있는데 이를, 명시적 타입 변환 또는 타입 캐스팅이라고 부른다.
기본적으로 원시 값은 변경이 불가능하므로 타입 변환이라는 것은 실제 값을 변경하는 것이 아닌 변경된 타입의 값을 새로 만들어 식별자에 바인딩을 하는 것이다.

반면에 의도와는 상관없이 표현식을 평가하는 중에 js 엔진이 암묵적으로 타입을 변경하는 경우가 있다. 이를 암묵적 타입 변환이라고 한다. 암묵적 타입 변환에 대하여 잘 숙지하지 않으면 예기치 못한 동작이나 오류가 발생할 수 있으므로 잘 익혀도어야 한다.

## 암묵적 타입 변환

js 엔진은 표현식 평가 시 코드 문맥에 맞지 않는 상황이 발생할 경우 가급적 (항상 그렇지는 않음) 암묵적 타입 변환을 통해 평가를 진행하고 에러를 발생시키지 않는다. 암묵적 타입 변환을 통해 변환된 값은 문자열, 숫자, 불리언 타입 중 하나가 된다.

### 문자열 타입으로 변환

크게 다음 2가지 경우가 있다.

- 템플릿 리터럴 표현식의 평가 결과는 문자열로 암묵적 타입 변환된다.
- 문자열 연결 연산자 표현식에서 문자열이 타입이 아닌 피연산자를 문자열로 암묵적 타입 변환된다.

### 숫자 타입으로 변환

- 산술 연산자의 피연산자가 숫자 타입이 아닌 경우 숫자 타입으로 암묵적 변환한다. 변환이 불가능한 경우 NaN 으로 평가된다.
- 비교 연산자의 경우도 마찬가지이다.
- - 단항 연산자는 숫자 타입에 사용하면 아무 효과도 없지만 피연산자가 숫자 타입이 아니면 숫자 타입의 값으로 암묵적 변환한다. 예컨대 '', [], null, false 는 0으로 , true는 1로 평가한다.
- 위의 경우에서 {}, 비어있지 않은 배열, undefined 는 변환이 불가능해 NaN 으로 평가됨을 주의하자.

### 불리언 타입으로 변환

제어문이나 삼항 조건 연산자의 조건식을 불리언 타입으로 평가되어야 하므로 만약 그렇지 않은 경우 불리언 타입으로 암묵적 변환된다.

이때 불리언 타입이 아닌 값을 truthy (true로 암묵적 변환) 또는 falsy (false로 암묵적 변환) 로 평가하는데, falsy 로 평가하는 값은 다음의 7가지 뿐이다.

- false
- undefined
- null
- 0
- -0
- NaN
- ''

  이 7가지 이외에는 모두 truthy로 평가한다.

## 명시적 타입 변환

### 문자열 타입으로 변환

- String 생성자 함수에 인수로 변환할 값을 전달하고 new 없이 호출한다.
- Object.prototype.toString() 을 사용하는 방법
- (암묵적 변환) : 문자열 연결 연산자 사용하기

```js
String(1); // '1'
(1).toString(); // '1'
1 + ''; // '1'
```

### 숫자 타입으로 변환

- Number 생성자 함수에 인수로 변환할 값을 전달하고 new 없이 호출한다.
- 문자열에 한해서 parseInt, parseFloat 를 사용한다
- (암묵적 변환) : 단항 산술 연산자 + 를 사용한다.
- (암묵적 변환) : 산술 연산자 \* 를 사용한다.

```js
Number(true); // 1
parseInt('1'); // 1
+'2'; // 2
'2' * 1; // 2
```

### 불리언 타입으로 변환

- Boolean 생성자 함수에 인수로 변환할 값을 전달하고 new 없이 호출한다.
- 부정 논리 연산자 !를 2번 사용한다.

```js
Boolean(0); // false
!!'hi'; // true
```

## 단축 평가

논리 연산자 중 논리합 || 과 논리곱 && 는 논리 결과를 결정한 피연산자로 평가된다. 이처럼 평가 도중에 논리 결과가 확정된 경우 나머지 평가 과정을 생략한다고 해서
**단축 평가** 라고 부른다.

```js
'dog' || 'cat'; // 'dog' 를 평가하면서 논리 결과가 true로 결정되었으므로 'dog' 를 반환한다.
'' || 'cat'; // ''는 false로 평가되어 아직 논리 결과를 정할 수 없고 'cat'을 평가하면서 true로 확정되므로 'cat'을 변환한다.
false || ''; // '' 반환
'dog' && 'cat'; // 'dog'는 true로 평가되나 아직 논리 결과를 정할 수 없고 'cat'을 평가면서 논리 결과가 true로 결정되므로 'cat' 반환한다.
'dog' && ''; // '' 반환
'' && 'cat'; // '' 가 false로 평가되어 논리 결과가 false로 확정되므로 '' 반환
```

&& 단축 평가를 이용하여 조건이 truthy 로 평가될 때 실행하는 if문을 대체할 수 있다.

```js
var bool = true;
var message = '';

if (bool) message = '참입니다';

// 좌항의 피연산자가 참이므로 && 의 평가 결과는 우항의 피연산자를 그대로 반환한다.
message = bool && '참입니다';
```

|| 는 같은 논리로 어떤 조건이 falsy 로 평가될 떄 실행할 if문을 대체할 수 있다.

```js
var bool = false;
var message = '';

if (!bool) message = '거짓입니다';

message = bool || '거짓입니다';
```

단축 평가를 유용하게 사용하는 패턴이 있다.

### 객체의 프로퍼티를 참조할 떄

객체의 프로퍼티를 참조할 때 객체를 가리키는 식별자가 사실 객체가 아니라 null 또는 undefined를 참조하고 있는 경우 오류가 발생한다. 이를 단축평가로 막을 수 있다.

```js
var fake = null;
var value = fake && fake.value;
// 만약 객체라고 생각했던 것이 null 또는 undefined 이면 그것이 반환되고 아닌 경우 의도한 대로 작동한다. 어느 쪽이든 에러는 발생하지 않는다.
```

### 함수 매개변수의 기본값 설정

함수 호출시 인수를 매개변수보다 적게 전달하는 경우 undefined가 할당되는데 이 경우 단축 평가를 이용해 기본값을 설정해 줄 수 있다.

```js
function getStringLength(str) {
  str = str || ''; // str이 undefined일 경우 || 우항의 피연산자가 str에 할당된다.
  return str.length;
}
```

## 옵셔널 체이닝 연산자

ES11에서 도입된 연산자로 ?. 라고 사용한다.
좌항의 피연산자가 null 또는 undefined 인 경우 undefined를 반환하고, 그렇지 않다면 우항의 프로퍼티 참조를 이어간다. 설명을 읽어보면 방금 위에서 보았던 객체의 프로퍼티를 참조할 때 객체가 사실 null 이나 undefined 인 경우의 문제를 해결하기 위해서 만들어진 것이다.

```js
var fake = null;

// 이전 방식
var value = fake && fake.value;
// 옵셔널 체이닝 연산자
var value = elem?.value;
```

또한 && 를 사용하는 경우 좌항 피연산자가 falsy 값인 경우 좌항 피연산자를 반환하는데, 0 이나 '' 은 falsy 값이므로 이것이 좌항 피연산자로 사용되면 0 이나 '' 글 그대로 반환한다. 하지만 0 이나 '' 은 문제의 여지가 있다. 이 문제를 ?. 가 해결한다. ?. 는 null 과 undefined 만 인정하기 떄문이다.

```js
var str = '';

var length = str && str.length;

console.log(length); // ''
// '' 가 falsy 값 이므로 false 로 평가되어 str 이 그대로 반환된다.

var length = str?.length;
console.log(length); // 0
```

## null 병합 연산자

null 병합 연산자 ?? 는 좌항의 피연산자가 null 또는 undefined 인 경우 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환한다. 이것 또한 위에서 살펴본 변수가 기본값을 설정할 때에 유용하게 사용할 수 있다.

|| 를 사용해서 기본값을 설정하는 경우 falsy 값이 좌항의 피연산자인 경우 우항의 피연산자를 반환하는데, 이것은 '' 나 0 이 좌항의 피연산자인 경우 문제가 될 수 있다. ?? 는 오직 undefined와 null 만을 인정한다.

```js
var foo = '' || 'string'; // 'string'
// 하지만 이것은 '' 도 유효한 입력이 될 수 있는 경우에는 곤란하다.

var foo = '' ?? 'string'; // ''
// null 병합 연산자로 문제를 해결했다.
```
