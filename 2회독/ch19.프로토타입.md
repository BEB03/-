# 19. 프로토타입

**js는 프로토타입으로 상속을 구현한다.**

- 상속 : 객체지향의 핵심 개념으로 다른 객체의 프로퍼티와 메서드를 이어받아 사용하는 것

상속은 어떠한 개념으로 js에서는 프로토타입이라는 방법으로 이 개념을 구현한다. 프로토타입은 어떠한 객체로 생성자 함수의 prototype 프로퍼티에 바인딩 되어있다. 즉, 생성자 함수와는 별개로 존재하고 있다.

프로토타입은 객체이므로 프로퍼티와 메서드를 가질 수 있으며 이것들은 해당 프로토타입과 연결되어 있는 생성자 함수가 생성하는 인스턴스들이 상속받아서 사용할 수 있다. (정확히 어떻게? 라는 질문은 뒤에서 해결)

## [[prototype]]

모든 객체는 [[prototype]] 내부 슬롯을 가지며 이 값은 프로토타입 객체의 참조다. 내부 슬롯이므로 직접 접근은 불가능 하지만 `__prototype__` 접근자 프로퍼티로 간접 접근할 수 있다. 따라서 생성자 함수, 프로토타입 객체, 인스턴스는 연결되어 있다

- 생성자 함수의 prototype 프로퍼티가 프로토타입을 가리킨다.
- 프로토타입의 constructor 프로퍼티가 생성자 함수를 가리킨다.
- 인스턴스의 `__prototype__` 가 프로토타입을 가리킨다.

하지만 직접 상속으로 `__prototype__` 을 사용할 수 없는 경우도 있어 `__prototype__` 을 사용하는 것은 권장되지 않는다. 그 대신 `__prototype__` 접근자 프로퍼티의 get, set을 사용하기 위해서 다음과 같은 방법이 권장된다.

```js
const obj = {};
const parent = { x: 1 };

Object.getPrototypeOf(obj); // `__prototype__` 의 get 메소드를 대신한다.
Object.setPrototypeOf(obj, parent); // `__prototype__` 의 set 메소드를 대신한다.
```

## 객체 리터럴 표기법에 의해 생성된 객체

위에서는 생성자 함수의 경우를 다루었다. 프로토타입의 constructor 는 해당 프로토타입을 상속받는 인스턴스를 생성한 생성자 함수를 가리킨다.  
만약 객체 리터럴로 생성자 함수 없이 객체를 생성한다면 이 경우에도 같게 동작할 것인가?

ECMA 표준에 따르면 생성자 함수 호출과 리터럴의 평가는 추상 연산 OrdinaryObjectCreate 를 호출하는 것은 동일하지만 세부 사항 몇 가지가 다르며 결론은 리터럴로 생성된 객체는 **Object 생성자 함수가 생성한 것이 아니다.**

하지만 리터럴로 생성한 객체가 프로토타입으로 부터 상속받은 constructor 프로퍼티를 확인해 보면 Object 와 연결되어 있다.

![19-1](img/19-1.png)

리터럴로 생성한 객체도 상속을 위해서 프로토타입이 필요하기 때문에 그 프로토타입과 쌍을 이루는 (가상의) 생성자 함수가 필요하다. 그래서 결론은 어떤 방식으로 생성하든 객체는 다 동일한 특성을 가지고, 따라서 위의 예제처럼 **constructor 가 가리키는 생성자 함수를 리터럴을 생성한 생성자 함수로 생각해도 크게 무리는 없다는 것이다.** (실제로는 그렇게 생성하지 않았지만!)

## 프로토타입의 생성 시점

프토토타입 객체는 생성자 함수가 생성되는 시점에 같이 생성된다.

따라서 사용자 정의 생성자 함수의 경우 함수 선언문으로 함수를 선언하면 런타임 이전에 함수 선언문이 평가되어 함수 객체를 생성하고 이 때 프로토타입도 같이 생성된다.

![19-2](img/19-2.png)

반면 함수 표현식은 값이 할당문이 실행되는 런타임에 평가된다.

![19-3](img/19-3.png)

빌트인 생성자 함수는 전역 객체 생성 시점에 생성되므로 빌트인 생성자 함수와 연결되어 있는 프로토타입도 그러하다.

## 생성 방식에 따른 프로토타입의 결정

## 프로토타입 체인

앞에서 객체는 자기가 상속받은 프로토타입의 메서드나 프로퍼티를 사용할 수 있다고 하였는데 프로토타입 체인은 **그럼 그 상속을 어떻게 하는 것인가?**에 대한 답변이다.  
js의 객체는 객체의 프로퍼티 / 메서드에 접근할 때 해당 객체에 접근하려는 프로퍼티가 없으면 [[prototype]] 내부 슬롯의 참조를 따라서 프로토타입의 프로퍼티를 검색하게 되는데 이것이 프로토타입 체인이며 이것이 상속을 구현하는 방식이다.

접근하려는 프로퍼티가 없으면 [[prototype]] 내부 슬롯에 바인딩 되어 있는 프로토타입 객체로 이동하여 접근하려는 프로퍼티를 검색하고, 만약 거기에도 없으면 검색을 했던 해당 프로토타입 객체의 [[prototype]] 내부 슬롯에 바인딩 되어있는 프로토타입 객체로 이동하여 또 검색하고...

나올 때까지 검색하며 만약 체인의 종점인 Object.prototype([[prototype]] 의 값이 null임)에서도 찾을 수 없을 경우 undefined를 반환한다. (이때 오류 발생하지 않음)

## 오버라이딩

인스턴스 프로퍼티를 프로토타입 프로퍼티와 같은 이름으로 추가하면 인스턴스 프로퍼티가 프로토타입 프로퍼티를 오버라이딩 하였고 프로토타입 프로퍼티는 가려지는 (섀도잉) 현상이 발생한다. 인스턴스에서 프로퍼티를 삭제하는 경우에도 인스턴스에서 프로퍼티가 삭제(존재했다면)되지 프로토타입 프로퍼티에는 영향이 없다.  
즉 하위 객체에서 프로토타입에 get 은 허용되지만(그래서 프로토타입 체인에 따라 상속받아 쓸 수 있지만) set은 허용되지 않는다.

## 프로토타입 교체

프로토타입 객체는 교체가 가능하다.

먼저 생성자 함수 내에서 생성자함수.prototype 에 값을 대입해서 바꿀 수가 있다. 이 경우 생성자함수.prototype 내에 constructor를 따로 지정하지 않으면 생성자 함수와 constructor 간의 연결이 끊어지게 되고, 인스턴스에서 constructor 를 검색하면 프로토타입 체인을 따라서 생성자함수.prototype(여기에는 지금 constructor가 없으므로) 의 상위 프로토타입에서 constructor를 찾게 된다.

두 번째는 인스턴스 생성 후에 Object.setProrotypeOf()를 사용하여 프로토타입의 교체가 가능하다. 이 경우에도 마찬가지로 constructor 에 관한 이슈가 있고, 이 경우에는 생성자 함수의 prototype 프로퍼티가 교체된 객체를 가리키지 않는다는 문제가 추가로 발생한다. 따라서 이 부분도 추가 설정을 해 주어야 한다.

이렇게 프로토타입을 직접 교체하는 것은 번거로운 작업이라 권장되지 않는다. (직접 상속이나 클래스를 활용하자)

## instanceof 연산자

다음의 꼴로 사용하는 instanceof 연산자는 우변의 생성자 함수의 prototype 프로퍼티에 바인딩 된 객체가 좌변의 **객체**의 프로토타입 체인상에 존재하는 지를 bool 로 평가한다.

```js
객체 instanceof 생성자 함수
```

아까 교체의 예시를 보자.  
생성자 함수 내에서 prototype 프로퍼티를 통해서 프로토타입 객체를 교채하였다면 constructor와 생성자 함수 간의 관계는 깨지나 인스턴스의 프로토타입 체인에는 변화가 없으므로 instanceof 의 결과값은 변하지 않을 것이다.  
반면 인스턴스 생성 후에 Object.setProrotypeOf()로 프로토타입 객체를 교체하였다면 이 경우 생성자 함수의 prototype 프로퍼티와 교체된 프로토타입 객체의 관계가 깨지므로 instanceof 의 결과값이 변하게 된다.

## 직접 상속

Object.create 는 첫 번째 매개변수로 객체를 전달받고, 두 번째 매개변수를 옵션으로 객체의 프로퍼티 키와 디스크럽터 를 받아서 첫 번째 매개변수를 프로토타입 객체로 가지는 객체를 생성하여 반환한다.

이 방법은 new 없이 객체를 생성하며, 직접 프로토타입을 지정하고, 객체 리터럴로 생성한 객체도 상속 받을 수 있는 장점이 있다.

### ES6 에서는

직접 상속은 장점이 있지만 두 번째 매개변수로 만들 객체의 프로퍼티를 정의하는 것이 번거롭다. 이를 편하게 만드려고 ES6에서는 객체 리터럴 내부에서 `__proto__`로 직접 상속을 구현할 수 있다.

```js
const proto = { x: 10 };

const obj = {
  y: 20,
  __proto__: proto,
};
```

## 정적 프로퍼티와 정적 메서드

생성자 함수(또한 객체이므로)가 가지고 있는 프로퍼티와 메서드를 일컫는 말이며 생성자 함수가 생성한 인스턴스에서는 프로토타입 체인상에 없는 것이므로 호출할 수가 없다. 만약 메서드 내에서 인스턴스를 참조할 필요가 없다면 정적으로 정의하여서 인스턴스를 만들지 않고도 메서드를 사용할 수 있는 장점이 있을 것이다.

## in 연산자

객체 내에 특정 프로퍼티가 존재하는 지를 확인한다. 이 때 상속받은 프로퍼티도 인정한다.

```js
프로퍼티 키 in 객체
```

상속을 제외한 고유한 프로퍼티인지를 확인하고 싶다면 **Object.prototype.hasOwnProperty()** 를 사용할 수 있다.

## for ... in

해당 문법은 객체의 프로퍼티를 순회하며 변수에 프로퍼티 키를 할당한다. 이 때 상속받은 프로퍼티도 대상이나 열거 불가능한, 즉 프로퍼티 어트리뷰트 [[Enumeralbe]] 의 값이 false이면 제외된다. 프로퍼티 키가 심벌인 경우도 제외된다.

```js
for (변수 in 객체) {
  // 코드
}
```

만약 상속받은 프로퍼티는 순회하고 싶지 않다면 위에서의 **Object.prototype.hasOwnProperty()**를 코드 블록 내에서 실행하여 따로 확인해 주어야 한다.

## Object.keys

위에서 상속받지 않은 자신만의 프로퍼티를 순회하고 싶은데 **Object.prototype.hasOwnProperty()**로 확인하는 것이 번거로우므로 Object.keys()를 사용할 수 있다.

- Object.keys() : 열거 가능한 자신의 프로퍼티 키를 배열로 반환한다.
- Object.values() : 열거 가능한 자신의 프로퍼티 값을 배열로 반환한다.
- Object.entries() : 열거 가능한 자신의 프로퍼티 키-값 쌍의 배열을 배열에 담아 반환한다.
