# 23. 살행 컨텍스트

## 소스 코드의 분류

js의 소스코드는 4가지 타입으로 분류된다.

- 전역 코드 : 전역에 존재하는 소스코드.
- 함수 코드 : 함수 내부에 존재하는 소스코드.
- eval 코드 : 빌트인 전역 함수 eval에 인수로 전달되는 소스코드.
- 모듈 코드 : 모듈 내부에 존재하는 소스코드.

각 코드는 실행 컨텍스트를 생성하며, 소스코드의 종류 별로 실행 컨텍스트의 생성 과정과 관리하는 내용이 다르므로 구분을 지을 필요가 있다.

## 소스코드의 평가와 실행

소스코드는 실행 전에 평가 과정을 거친다. 이 과정에서는 선언문만 먼저 실행하여 생성된 식별자를 키로 실행 컨텍스트가 관리하는 스코프(렉시컬 환경의 환경 레코드)에 등록한다.

평가가 끝나면 소스코드가 순차적으로 실행되는 런타임이 시작된다. 이 때 변수나 함수의 참조는 실행 컨텍스트가 관리하는 스코프에서 식별자를 검색하여 사용한다. 또한 변수 값의 변경 같은 코드 실행 결과는 다시 실행 컨텍스트가 관리하는 스코프에 등록된다.

즉, 실행 컨텍스트는 실행 컨텍스트 스택과 렉시컬 환경으로 구성된다.

## 예제

실행 컨텍스트의 작동 예제를 알아보자.

```js
const x = 1;
const y = 2;

function foo(a) {
  const x = 10;
  const y = 20;
  console.log(a + x + y);
}

foo(100);

console.log(x + y);
```

1. 전역 코드 평가

   소스코드는 실행 전에 평가 과정을 거친다고 했다. 먼저 전역 코드를 평가하면서 전역 코드 내의 선언문을 실행한다. 이 결과로 생성된 전역 변수, 전역 함수가 **실행 컨텍스트가 관리하는 전역 스코프에 등록**된다.

2. 전역 코드 실행

   코드 평가 과정이 끝나면 런타임이 시작되어 전역 코드가 순차적으로 시작된다. 변수 x ,y 에 값이 할당되고 함수 foo가 호출된다.

3. 함수 코드 평가

   함수를 만나면 함수 내부로 진입하여 마찬가지로 실행 전에 평가 과정을 거친다. 매개변수와 함수 내에 선언된 진역 변수 선언이 먼저 실행되고, 그 결과로 생성된 매개변수, 지역 변수가 실행 컨텍스트가 관리하는 지역 스코프에 등록이 된다. 또한 arguments 객체가 생성되어 지역 스코프에 등록되고 this 바인딩도 결정된다.

4. 함수 코드 실행

   평가 과정이 끝나면 순차적으로 실행된다. 이때 매개변수 a 와 지역 변수 x, y 에 값이 할당 되고 그 다음 console 메서드가 호출된다.  
   js 는 식별자 검색을 위한 메커니즘으로 스코프 체인을 사용한다고 하였다. console 식별자를 찾기 위해서 스코프 체인을 사용한다. 하지만 console 은 전역 객체의 프로퍼티이지 전역 변수가 아니므로 이 검색을 위해서는 **전역 객체의 프로퍼티도 스코프 체인을 통해 검색이 가능하도록 뭔가 작업이 필요하다.**

   일단 이게 되었다고 하면 console.log 에서 log 라는 console 객체의 메서드를 검색하게 된다. js는 객체의 프로퍼티와 메서드 검색을 위해서 프로토타입 체인을 이용한다고 하였다. 이를 이용해 log 메서드를 검색한 후 표현식 console.log의 인수인 a + x + y 가 평가된다. a, x, y 는 식별자이므로 스코프 체인을 통해서 검색한다.

   console.log가 실행되고 나면 함수 코드는 모두 실행되었으므로 종료되고 다시 전역 코드로 돌아가서 실행이 마저 진행된다. 그래서 마지막 console.log(x + y)가 아까와 같은 방식으로 프로토타입 체인과 스코프 체인을 통해 검색되고 실행된다.

결국 코드가 실행되려면 식별자들을 스코프를 구분하여 등록하고 바인딩된 값을 관리할 수 있어야 하며, 스코프 체인을 형성해야 하고, 코드 실행 순서를 제어할 수 있어야 한다.

이 모든 것을 관리 하는 것이 실행 컨텍스트이다. 소스코드 실행해 필요한 위와 같은 환경을 제공하고 실행 결과를 관리하는 영역으로, 스코프와 코드 실행 순서 관리를 구현한 내부 메커니즘으로, 스코프는 **렉시컬 환경**으로 코드 실행 순서 관리는 **실행 컨텍스트 스택**으로 관리한다.

## 실행 컨텍스트 스택

4가지 타입으로 분류되는 js의 소스코드는 실행 컨텍스트를 생성하게 되는데, 소스코드에 의해서 생성된 실행 컨텍스트는 스택 자료구조로 관리되며 이것을 실행 컨텍스트 스택 (또는 콜 스택)이라고 부른다.

스택은 차례대로 쌓이는 것을 추상화한 자료구조로 스택의 위에 있는 순서대로 실행하는 특징을 가지고 있다. 소스코드가 실행 컨텍스트를 생성하게 되면 스택에 쌓이게 (push) 되며, 실행이 끝나서 종료되면 실행 컨텍스트는 스택에서 pop되게 된다.

따라서 아까의 예제를 보자면 전역 코드가 평가되어 전역 실행 컨텍스트를 생성하고 이것이 실행 컨텍스트 스택에 쌓이게 (push) 된다.

```

[전역 실행 컨텍스트    ]
```

그리고 전역 코드 실행 도중에 foo가 호출되어서 foo 내부로 제어권이 이동하고, 함수 foo 가 평가되어 또 실행 컨텍스트를 생성하게 되면 스택에 쌓이게 된다. 이때 전역 코드가 생성한 실행 컨텍스트는 여전히 스택에 있으므로, 이 위에 함수 실행 컨텍스트가 쌓이게 된다.

```
[함수 foo 실행 컨텍스트]
[전역 실행 컨텍스트    ]
```

그리고 foo가 실행을 마치고 종료되면 함수 foo 실행 컨텍스트는 스택에서 빠지게 (pop) 된다. 그리고 다시 전역 코드로 제어권이 이동하여 전역 코드를 실행한다.

```

[전역 실행 컨텍스트    ]
```

전역 코드도 실행이 전부 끝나서 종료되면 전역 실행 컨텍스트도 pop 된다.

```


```

이처럼 실행 컨텍스트 스택은 코드의 실행 순서를 관리하며 언제나 스택의 맨 위에 있는 실행 컨텍스트를 생성한 코드가 실행되게 된다.  
따라서 다음 예제에서 콘솔은 세번째 -> 두번째 -> 첫번째 순으로 찍힌다. first의 콘솔이 찍히기 전에 second 호출로 second 실행 컨텍스트가 위에 쌓이고, second 콘솔 찍히기 전에 third 호출로 third 실행 컨텍스트가 또 위에 쌓인다. 맨 위에 있는 실행 컨텍스트를 생성한 코드부터 실행되므로 그렇다.

```js
function first() {
  second();
  console.log('첫번째');
}
function second() {
  third();
  console.log('두번째');
}
function third() {
  console.log('세번째');
}
first();
```

## 렉시컬 환경

실행 컨텍스트 환경이 코드 실행 순서를 관리했다면 렉시컬 환경은 식별자와 스코프를 관리한다.  
렉시컬 환경은 객체 형태의 스코프를 생성하여 그 안에 식별자를 키로, 바인딩된 값을 값으로 저장하는 식으로 식별자를 관리한다.

이 장에서는 복잡하고 특수한 일부를 생략하고, 간략한 설명을 진행한다고 밝히고 있다. 간략하게 정리한 렉시컬 환경의 구조는 다음과 같다.

- 환경 레코드 : 스코프에 등록된 식별자를 등록하고 바인딩된 값을 관리하는 저장소이다. 소스코드의 종류마다 관리하는 값의 차이가 있다.
- 외부 렉시컬 환경에 대한 참조 : 이 컴포넌트는 상위 스코프를 가리킴으로 스코프 체인을 구현한다.

## 예제

다음 예제 코드와 함께 진행과정을 보자.

```js
var x = 1;
const y = 2;

function foo(a) {
  var x = 3;
  const y = 4;
  function bar(b) {
    const z = 5;
    console.log(a + b + x + y + z);
  }
  bar(10);
}

foo(20);
```

1. 전역 객체 생성

   전역 코드 평가 이전에 전역 객체가 생성된다. 전역 객체에는 빌트인 전역 함수, 빌트인 전역 프로퍼티, 표준 빌트인 객체, 호스트 객체등이 포함된다.

2. 전역 코드 평가

   실행 컨텍스트에서 살펴본 것처럼 전역 코드 실행 이전에 평가를 거친다. 먼저 전역 실행 컨텍스트를 생성, 콜 스택에 푸시한다.  
   그 다음 전역 렉시컬 환경을 생성하고 전역 실행 컨텍스트에 바인딩한다. 이 렉시컬 환경은 환경 레코드와 외부 렉시컬 환경에 대한 참조로 구성된다.

   2-1. **전역 환경 레코드** 생성
   전역 환경 레코드는 또 객체 환경 레코드와 선언적 환경 레코드 둘로 구성되어 있다.

   - 객체 환경 레코드 : var로 선언한 전역 변수와 전역 함수가 등록된다. 이 객체 환경 레코드는 전역 객체 BindingObject 와 연결되어서 전역 var와 전역 함수가 전역 객체의 프로퍼티가 되도록 만든다.

   - 선언적 환경 레코드 : ES6에서 let과 const 가 추가 되고 이것은 전역 변수로 선언해도 전역 객체의 프로퍼티가 되지 않게 설계되었기 때문에 따로 관리하게 되고 이것을 관리하는 곳이 선언적 환경 레코드이다.

   2-2. this 바인딩
   **전역 환경 레코드**의 [[GlobalThisValue]] 내부 슬롯에 this가 바인딩된다. 전역 코드에서 this 는 전역 객체를 가리키므로 [[GlobalThisValue]]에는 전역 객체가 바인딩된다.

   2-3. **외부 렉시컬 환경에 대한 참조** 설정
   **외부 렉시컬 환경에 대한 참조**는 현재 평가 중인 소스코드를 포함하는 외부 소스코드의 렉시컬 환경을 가리킨다. 현재 전역 코드를 평가 중이므로 '전역코드를 포함하는 외부 소스코드'는 존재하지 않으므로 '외부 소스코드의 렉시컬 환경'은 없고 **외부 렉시컬 환경에 대한 참조**에는 null이 할당된다.

3. 전역 코드 실행

   평가를 마친 전역코드는 이제 실행된다. 순차적으로 전역 변수에 값이 할당되고 foo(20)이 실행된다. foo 가 호출되면 식별자 결정을 위해서 현재 실행 중인 실행 컨텍스트부터 검색을 시작한다. 현재 실행 중인 전역 실행 컨텍스트에 foo 가 등록되어 있으므로 실행된다.

4. 함수 foo 코드 평가

   함수 foo 내부로 코드의 제어권이 이동하며 코드 평가가 시작된다. 전역 코드와 유사하게 레코드 생성과 바인딩등이 이루어진다.

   먼저 foo의 함수 실행 컨텍스트가 생성되고, foo 함수 렉시컬 환경이 생성되어 함수 실행 컨텍스트에 바인딩된다. 이것도 마찬가지로 환경 레코드와 외부 렉시컬 환경에 대한 참조로 이루어져 있다.

   4-1. 함수 환경 레코드 생성
   함수 내의 식별자들을 관리하게 되는 곳이다. 함수 내부에서 선언한 지역 변수와 중첩 함수, 추가로 함수만의 특별한 경우라고 할 수 있는 매개변수, argument 객체를 등록하고 관리한다.

   4-2. this 바인딩
   함수 환경 레코드의 [[ThisValue]] 내부 슬롯에 this가 바인딩된다. 이 this 바인딩 값은 함수 호출 방식에 따라 달라지며 예제의 경우에는 일반 함수 호출이므로 전역 객체가 바인딩된다.

   4-3. 외부 렉시컬 환경에 대한 참조 설정
   같은 원리로 설정된다. 현재 평가 중인 foo 함수 소스코드를 포함하는 외부 소스코드는 전역 코드이므로 '외부 소스코드의 렉시컬 환경' 은 전역 렉시컬 환경이다. 따라서 외부 렉시컬 환경에 대한 참조'에는 '전역 렉시컬 환경의 참조'가 할당된다.

   js 엔진은 함수 정의를 평가해서 함수 객체를 생성할 떄, 현재 실행 중인 실행 컨텍스트의 **렉시컬 환경**, (예컨대 이 예제에서 전역에서 선언된 함수 foo 가 평가될 때는 전역 실행 컨텍스트가 실행 중이다. foo 함수 실행 컨텍스트는 호출 후 제어권이 넘어간 뒤에 생성된다. 헷갈라지 말자) 즉 **상위 스코프**를 함수 객체의 내부 슬롯 [[Enviroment]]에 저장한다. '함수 렉시컬 환경의 **외부 렉시컬 환경에 대한 참조**'에 할당되는 것은 [[Enviroment]] 에 저장된 렉시컬 환경의 참조가 되고 [[Enviroment]] 가 함수가 정의된 곳을 기억함으로써 정의 위치에 따라 상위 스코프를 결정하는 렉시컬 스코프를 구현하게 된다.

5. 함수 foo 코드 실행

   평가가 끝나면 foo 코드가 실행된다. foo 함수 몸체 내부의 x, y 에 값이 할당된다. 이 x, y를 식별하기 위해 실행 중인 실행 컨텍스트의 렉시컬 환경, 즉 foo의 렉시컬 환경에서 x, y를 검색한다. 4-1에서 함수 환경 레코드 생성시에 지역 변수인 x, y가 등록되었으므로 검색된다.

6. 함수 bar 코드 평가

   함수 foo 코드를 평가할 때와 같은 논리로 진행된다. b, z, bar 의 arguments 가 bar의 렉시컬 환경의 함수 환경 레코드에 등록되고, this 바인딩이 되고(일반 호출이므로 [[ThisValue]] 에 전역 객체 바인딩 됨) 외부 렉시컬 환경에 대한 참조에는 bar를 포함하는 외부 소스코드는 foo 이므로 foo의 렉시컬 환경의 참조가 할당된다.

7. 함수 bar 코드 실행
   b, z에 값이 할당되고 console.log(a + b + x + y + z) 가 실행된다.

   7.1 console 식별자 검색
   console 식별자를 검색한다. 식별자는 스코프 체인 위에서 검색된다. 현재 실행 중인 실행 컨텍스트 (지금은 bar의 실행 컨텍스트) 부터 시작한다. 여기에는 console 식별자를 찾을 수 없으므로, 외부 렉시컬 환경에 대한 참조에 할당되어 있는 foo 함수 렉시컬 환경으로 이동하여 식별자를 검색한다. 여기도 없으므로 foo 렉시컬 관경의 외부 렉시컬 환경에 대한 참조가 가리키는 전역 렉시컬 환경으로 이동하여 검색한다.

   console은 전역 렉시컬 환경의 전역 환경 레코드를 구성하는 객체 환경 레코드에 바인딩된 BindingObject에서 찾을 수 있다.

   7.2 log 메서드 검색
   .log 로 작성되었으므로 console 객체의 프로토타입 체인을 따라서 메서드를 검색한다. log는 상속받지 않은 console 이 직접 소유한 메서드이다.

   7.3 표현식 a + b + x + y + z 평가
   메서드에 전달한 표현식을 평가하여 값으로 만들어야 한다. 식별자는 스코프 체인에서 검색한다. 아까 console을 검색하였듯이 현재 실행 중인 실행 컨텍스트의 렉시컬 환경에서 시작하여 외부 렉시컬 환경에 대한 참조로 이어지는 체인에서 검색한다.

   7.4 console.log()
   평가된 값을 인수로 전달하여 console.log 를 호출한다.

8. bar 함수 코드 종료

   bar는 모든 코드를 실행했으므로 종료되며 bar 함수 실행 컨텍스트는 콜 스택에서 팝되어 제거되며 이제 콜 스택의 최상위에 위치한 foo 함수 실행 컨텍스트가 실행중인 실행 컨텍스트가 된다.

9. foo 함수 코드 종료

   같은 원리로 foo 함수 실행 컨텍스트도 팝되고 전역 함수 실행 컨텍스트가 실행중인 실행 컨텍스트가 된다.

10. 전역 코드 실행 종료

    같은 원리로 전역 실행 컨텍스트도 팝되고 콜 스택은 비게 된다.

## 블록 레벨 스코프

함수는 예제에서 알아본 것 처럼 자신의 렉시컬 환경을 생성해서 함수 레벨 스코프를 만들었다. ES6의 let과 const는 블록 레벨 스코프를 지원하므로, 코드 블록이 실행되면 함수와 마찬가지로 렉시컬 환경이 생성되어 블록 레벨 스코프를 지원할 수 있어야 한다.

따라서 코드 블록이 실행되면 코드 블록을 위한 렉시컬 환경이 생성되고 블록 렉시컬 환경의 환경 레코드는 선언적 환경 레코드를 생성하여 let 과 const를 관리한다. 또한 블록 렉시컬 환경의 외부 렉시컬 환경에 대한 참조는

- [ ] 이전에 실행되고 있던 코드의 렉시컬 환경인가? 이 부분이 조금 모호하게 써 진것 같네.

### for 문

for 문 또한 코드 블록이고 블록 레벨 스코프를 지원한다. for 문의 변수 선언문에 let 키워드를 사용하였다면 for문은 코드 블록이 반복되서 실행될 때마다 블록 렉시컬 환경을 새로 생성한다. 이 때 for문은 렉시컬 환경이 새로 생성되더라도 **let으로 선언한 식별자와 for 코드 블록 내에서 선언된 지역 변수들의 값을 기억하고 있어야 한다.**

이를 위해 독립적인 렉시컬 환경으로 생성하여 식별자의 값을 유지하는데 여기서 24장에서 설명하는 클로저가 사용된다.
