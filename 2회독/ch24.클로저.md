# 24. 클로저

클로저는 js의 고유의 개념이 아닌 함수형 프로그래밍 언어의 특성이다.

MDN에서는 함수와 그 함수가 선언된 렉시컬 환경의 조합이라고 설명하고 있다.

## 렉시컬 스코프

js는 함수의 상위 스코프는 함수 호출이 아니라 함수가 선언된 위치에 따라서 정해지는 렉시컬 스코프를 따른다.

이 스코프의 위계 구조를 의미하는 스코프 체인은 자신의 렉시컬 환경이 외부 렉시컬 환경에 대한 참조를 통해서 상위 렉시컬 환경과 연결되는 것으로 구현된다. 따라서 함수의 상위 스코프를 결정한다는 것은 외부 렉시컬 환경에 대한 참조에 무엇을 저장할 것인가에 대한 문제이다. 이 저장할 값을 함수가 정의된 위치에 따라서 정하는 것이 렉시컬 스코프의 실체라고 할 수 있다.

## [[Enviroment]] 내부 슬롯

렉시컬 스코프를 위해서는 함수가 위의 과정으로 정해진 상위 스코프를 자신 어딘가 내부에 기억을 하고 있어야만 한다. 따라서 함수는 내부 슬롯 [[Enviroment]]에 자신이 정의된 환경, 즉 현재 실행 중인 실행 컨텍스트의 렉시컬 환경을 가리키는 상위 스코프의 참조를 저장한다.

이 작업은 함수 정의가 평가되어 함수 객체를 생성할 때 이루어진다.

예컨대 전역에서 정의된 함수 선언문은 전역 코드 평가시에 함수 객체가 생성된다. 이 때 [[Enviroemnt]] 에는 이 시점, 즉 전역 코드 평가 시점에 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조가 저장되는데, 전역 코드 평가 시점에 실행 중인 실행 컨텍스트는 전역 실행 컨텍스트이므로 [[Enviroment]]에는 전역 렉시컬 환경의 참조가 저장된다.

함수 내부에서 정의된 함수 표현식은 외부 함수 코드 실행 시점에 평가되어 함수 객체를 생성한다. 이 때 중첩 함수의 [[Enviroment]] 에는 (중첩 함수가 평가되는 시점에 실행 중인 실행 컨텍스트는 외부 함수 실행 컨텍스트 이기 때문에) 외부 함수 렉시컬 환경의 참조가 저장된다.

중요한 것은 함수는 [[Enviroment]]에 저장한 렉시컬 환경의 참조(= 상위 스코프)를 **자신이 존재하는 한 기억한다.**

다음 예제를 보자.

```js
const x = 1;

function foo() {
  const x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // 1
bar(); // 1
```

콘솔에 찍어보면 foo와 bar의 호출 결과는 둘 다 1이 나온다. bar는 foo 안에서 호출되지만 bar는 전역 함수로 함수 객체가 전역 코드 실행 시에 생성되므로 bar의 [[Enviroment]] 에는 전역 렉시컬 환경의 참조가 저장되어 있고, 따라서 bar에서 식별자 x를 검색할 때에는 bar 스코프에는 x가 없으므로 스코프 체인 ([[Enviroment]]에 저장되어있는 것 과 같은 외부 렉시컬 환경의 참조를 따라서)이 작동하여 그 다음은 전역에서 x를 검색하여 1이 나온다.

## 클로저와 렉시컬 환경

```js
const x = 1;

function outer() {
  const x = 10;
  const inner = function () {
    console.log(x);
  };
  return inner;
}

const innerFunc = outer();
innerFunc(); // 10
```

innerFunc()의 값은 10이 나온다.

런타임에 무슨 일이 있는지 따져본다면, x에 값이 할당 되고 innerFunc에 값이 할당되면서 outer 함수가 호출된다. outer 함수 내부로 제어권이 이동해서 평가 후 x = 10; 이 할당되고 inner 함수를 반환하고 outer 함수는 종료된다. 따라서 outer 함수의 실행 컨텍스트는 팝되어 제거되고 지역 변수 x 또한 생명 주기를 마감한다.

따라서 innerFunc, 즉 outer()의 값은 함수 inner 이다. 이제 마지막 줄에서 innerFunc() 를 하면 inner 함수 호출을 하게 되는데, 값이 1이 아니라 10이 나온다. 이미 outer 함수는 종료되었고 지역 변수 x도 생명 주기가 끝나는데 왜 이런 것일까?

이것은 함수가 [[Enviroment]] 에 상위 스코프를 저장하고 있으며 참조되고 있는 렉시컬 환경은 가비지 컬렉션의 대상이 되지 않고 남아있기 때문이다.

inner 함수 객체가 생성되는 것은 outer 함수의 코드 실행이 될 때이다. 따라서 inner 의 [[Enviroment]]에는 현재 실행 중인 실행 컨텍스트의 렉시컬 환경, 즉 outer 함수 렉시컬 환경의 참조가 저장된다. 이후 outer 코드가 끝나서 outer 실행 컨텍스트가 팝되어도 참조되고 있는 **outer 함수 렉시컬 환경**은 사라지지 않고 남아있다.

따라서 inner를 호출하였을 때 x 를 식별하기 위해서 스코프 체인을 사용하고, [[Enviroment]] 의 참조 값에는 여전히 outer 함수 렉시컬 환경의 참조가 저장되어 있으므로 outer 함수 렉시컬 환경에서 관리하고 있던 x (= 10)을 여전히 찾을 수 있다.

이처럼 외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료된 외부 함수의 변수를 참조할 수 있으며 이 때 이 중첩 함수를 **클로저**라고 부른다. 즉 클로저는 어떠한 함수를 일컫는 이름이다.

js의 함수는 기본적으로 [[Enviroment]]를 통해 상위 스코프를 기억하고 있다. 하지만 그렇다고 다 클로저라고 부르지 않는다. 클로저라고 부르려면 다음 두 가지를 만족해야 한다.

- 중첩 함수가 외부 함수의 식별자를 참조해야 한다. 상위 스코프의 식별자를 참조하지 않는다면 굳이 기억하고 있을 필요가 (즉, 외부 함수의 렉시컬 환경을 가비지 컬렉션의 대상으로 삼지 않을 이유가) 없다.
- 중첩 함수가 외부 함수보다 오래 살아남아야 (=생명주가기 더 길어야)한다. 이러면 중첩 함수가 더 오래살아남는 경우에도 상위 스코프를 참조할 수 있다는 클로저의 본질에 맞지 않는다.

따라서 중첩 함수가 상위 스코프의 식별자를 참조하며 외부 함수보다 오래 유지되는 경우에만 붙이는 이름이다.  
실제로 모던 브라우저는 저 조건을 만족하지 않으면 최적화를 통해서 식별자를 기억하지 않는다고 한다.

## 활용

그럼 클로저는 어디에 사용할 수 있을까, 클로저는 state(상태)를 안전하게 변경하고 유지하기 위해서 사용된다. 즉 상태를 은닉하고 특정 함수에게만 상태 변경을 허용하도록 하는 것이다.

```js
let num = 0;

const increase = function () {
  return num++;
};

increase(); // num == 1
increase(); // num == 2
increase(); // num == 3
```

increase를 통하여 num을 제어하려고 하고 있다. 하지만 num은 전역 변수로 선언되어있기 때문에 의도치 않은 변겨이 생길 수가 있다.  
그럼 num을 지역변수로 하면 어떨까?

```js
const increase = function () {
  let num = 0;
  return num++;
};

increase(); // num == 1
increase(); // num == 1
increase(); // num == 1
```

이번에는 num을 increase만 제어할 수 있게 되긴 하였지만 increase 호출 시마다 num이 초기화되어서 의도한 대로 작동이 되지 않는다.

여기서 클로저의 개념을 가져오면 어떨까? 내부 중첩 함수가 상위 스코프인 외부 함수의 변수를 참조하되 외부 함수는 호출 이후 소멸되어서 다른 곳에서 접근이 불가능 한 것을 아까 클로저에서 보았다. 이 개념을 토대로 다음과 같이 구성이 가능하다.

```js
const increase = (function () {
  let num = 0;
  return function () {
    return ++num;
  };
})();

increase(); // num == 1
increase(); // num == 2
increase(); // num == 3
```

increase를 즉시 실행 함수로 정의하여서 한 번만 호출하게 하고 (따라서 num에 값 할당은 딱 한번만 할 수 있게 되었고), 무기명 클로저 함수를 리턴하여서 num을 조작할 수 있도록 하였다. 클로저로 쓰인 무기명 함수는 increase 변수에 할당되어 (리턴값이므로) 호출될 수 있으며 또한 자신의 상위 스코프인 즉시 실행 함수의 렉시컬 스코프를 [[Enviroment]] 에 기억하고 있다.
