# 20. strict mode

# 21. 빌트인 객체

- 표준 빌트인 객체 : ECMA 사양에 정의된 객체로, 전역 객체의 프로퍼티로 제공되며 실행환경에 상관없이 사용 가능하다.
- 호스트 객체 : 실행환경에 따라 추가로 제공되는 객체를 말한다. 브라우저에서의 DOM, XMLHttpRequest 등이 있다.
- 사용자 정의 객체 : 사용자가 직접 정의한 객체이다.

## 표준 빌트인 객체

js는 40여 종의 표준 빌트인 객체를 지원한다. 이 중 Math, Reflect, JSON으 제외하면 모두 생성자 함수이다.  
표준 빌트인 객체는 여러가지 정적/프로토타입 메서드를 제공한다.

## 래퍼 객체

이 표준 빌트인 객체 중에는 문자열, 숫자, 불리언 객체를 생성하는 String, Number, Boolean 등이 있다. 이미 원시값이 존재함에도 불구하도 왜 이런 객체가 또 있는 것일까?  
이것은 유용한 프로퍼티와 메서드를 사용할 수 있게 함이다. 예컨데,

```js
const str = 'hello';

console.log(str.length); // 5
```

이 예제는 잘 작동한다. 분명 원시값인 문자열에 .length 로 객체 접근법을 사용하였는데 오류가 나지 않는다.  
이것은 래퍼 객체 라는 것의 존재 때문인데, 원시값 중 문자열, 숫자, 불린의 경우 객체 접근법 (. 또는 [])를 사용하면 래퍼 객체라는 임시 객체로 변환시켜서 String, Number, Boolean 생성자 함수의 프로퍼티와 메서드를 호출하고 다시 원시값으로 되돌린다

따라서 문자열, 숫자, 불리언, 심벌은 암묵적으로 생성되는 래퍼 객체를 통해서 마치 객체처럼 동작하며 표준 빌트인 객체의 프로퍼티와 메서드를 사용할 수 가 있으므로 String, Number, Boolean 생성자 함수로 직접 객체를 생성하는 것을 필요하지도 않고 권장되지도 않는다.

## 전역 객체

코드 실행 이전에 js 엔진에 의해서 생성되는 특수한 객체로, 어떤 객체에도 속하지 않는 최상위 객체이다. 브라우저에서는 window(self, this, frames), 노드에서는 global을 의미하며 globalThis 는 이를 통일한 식별자이다.

전역 객체를 참조할 때 이름을 생략할 수 있으며 표준 빌트인 객체, 호스트 객체, 전역으로 선언한 var, 암묵적 전역, 전역 함수를 프로퍼티로 가지게 되며, 또한 기본적으로 몇 가지 프로퍼티와 메서드를 가지고 있다.

### 빌트인 전역 프로퍼티

- Infinity : 무한대를 나타내는 숫자값 Infinity를 값으로 가진다.
- NaN : 숫자가 아님을 뜻하는 NaN을 값으로 가진다. NaN 값의 타입은 number이다.
- undefined : 이 프로퍼티는 원시 값 undefined를 값으로 가진다.

### 빌트인 전역 함수

- eval : js 코드를 나타내는 문자열을 인수로 받아서 런타임에 평가/실행한다. 보안 / 성능 저하의 이유로 사용하지 않는다.
- isFinite : 인수가 무한수 인지를 검사한다.
- isNaN : 인수가 NaN 인지를 검사한다.
- parseFloat / parseInt : 문자열을 실수(정수)로 변환한다.
- encodeURI / decodeURI : 완전한 URI를 문자열로 받아서
- encodeURIComponent / decodeURIComponent :

- [ ] 마무리

### 암묵적 전역

js 엔진은 선언하지 않은 식별자에 값을 할당하는 경우 앞에 window가 생략된 것 처럼 해석하여 전역 객체의 프로퍼티로 생성하게 되고 이 현상을 암묵적 전역이라고 한다.

```js
y = 20; // window.y = 20; 으로 해석
```

이 암묵적 전역은 전역 변수처럼 사용할 수는 있지만 단순히 전역 객체의 프로퍼티 이기 때문에 변수 호이스팅이 발생하지 않고, delete 연산자로 삭제가 가능하다.

# 22. this

객체의 메서드는 자신이 속한 객체의 프로퍼티를 변경할 수 있어야 한다. 이게 가능하려면 먼저 자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야 한다.  
헌데 만약 생성자 함수로 객체를 생성하였다고 하자. 생성자 함수를 정의하는 것은 인스턴스를 생성하기 이전 시점이다. 따라서 메서드는 자신이 속한 객체(인스턴스)를 식별할 식별자는 아직 알 수 없다. 이런 문제를 해결하기 위해서 js는 this 라는 식별자를 제공한다.

this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 변수이다. js 엔진이 암묵적으로 생성하며, 함수 호출시 arguments 객체와 함께 this가 함수 내부에 전달되어서 this를 함수 내의 지역 변수 처럼 사용할 수 있다.

## this 바인딩

그런데 이 this에 무엇을 전달 받느냐가 함수 호출 방식에 따라 달라진다.

### 생성자 함수 호출

생성자 함수 내부의 this는 생성자 함수가 (미래에) 생성할 인스턴스를 가리킨다. 중요한 것은 생성자 함수를 new와 함께 호출하여 생성자 함수로 동작하게 한 경우에만 그렇다는 것이다. 생성자 함수는 함수이므로 일반 함수 호출도 가능한데, 이 때는 this에 바인딩 되는 값이 달라진다.

- [ ] 예제

## 메서드 호출

메서드 내부의 this 에는 메서드를 호출한 객체가 바인딩된다. 이 때 중요한 것은 메서드를 소유한 객체가 아닌 호출한 객체가 바인딩된다는 것이고, 또한 메서드를 메서드로 호출한 것이 아닌 일반 함수로 호출한 경우에는 this 바인딩 되는 값이 달라진다는 것이다.

- [ ] 예제

## 일반 함수 호출

이 경우 this에는 전역 객체 (브라우저에서는 window 가 된다.) 가 바인딩된다. 어디서 호출하던 간에 일반 함수 호출이라면 this에는 전역 객체가 바인딩된다. this는 메서드 내에서 자신이 속한 객체를 참조하기 위해 만들어진 것인데, 따라서 일반 함수 호출 시에는 this를 사용할 이유가 없다. 그래서 strict mode에서는 일반 함수 호출 시에 this에 전역 객체 대신 undefined를 바인딩한다.

이것은 또한 메서드 내에서 콜백이나 중첩 함수를 사용할 경우 문제가 된다.

```js
// 메서드 내의 콜백 함수
const obj = {
  foo() {
    console.log(this); // {foo: f}
    setTimeout(function () {
      console.log(this); // window
    }, 1000);
  },
};

// 메서드 내의 중첩 함수
const obj = {
  foo() {
    console.log(this); // {foo: f}
    function bar() {
      console.log(this); // window
    }
  },
};
```

위의 예제에서 setTimeout의 콜백과 bar 함수 내부의 this는 일반 함수 호출이므로 window를 가리킨다. 하지만 메서드 내에서 콜백이나 중첩 함수를 사용한다는 것은 메서드의 동작을 돕는 역할을 의도하고 사용하는 것일텐데 이 때 메서드 내부의 this와 콜백 / 중첩 함수의 this의 바인딩 값이 서로 다르다는 것은 부자연스럽다.

이 문제를 해결하는 방법은 3가지가 있다. 먼저 메서드 내의 this를 다른 변수에 할당하는 것

```js
// 메서드 내의 콜백 함수
const obj = {
  foo() {
    console.log(this); // {foo: f}
    const that = this;
    setTimeout(function () {
      console.log(that); // {foo: f}
    }, 1000);
  },
};
```

두 번째는 콜백 / 중첩 함수를 화살표 함수로 선언하는 것 (나중에 화살표 함수에서 다루자)  
마지막은 bind 메서드를 이용한 간접 호출이다.

## apply / call / bind에 의한 간접 호출
