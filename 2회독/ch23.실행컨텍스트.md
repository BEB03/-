# 23. 살행 컨텍스트

## 소스 코드의 분류

js의 소스코드는 4가지 타입으로 분류된다.

- 전역 코드 : 전역에 존재하는 소스코드.
- 함수 코드 : 함수 내부에 존재하는 소스코드.
- eval 코드 : 빌트인 전역 함수 eval에 인수로 전달되는 소스코드.
- 모듈 코드 : 모듈 내부에 존재하는 소스코드.

각 코드는 실행 컨텍스트를 생성하며, 소스코드의 종류 별로 실행 컨텍스트의 생성 과정과 관리하는 내용이 다르므로 구분을 지을 필요가 있다.

## 소스코드의 평가와 실행

소스코드는 실행 전에 평가 과정을 거친다. 이 과정에서는 선언문만 먼저 실행하여 생성된 식별자를 키로 실행 컨텍스트가 관리하는 스코프(렉시컬 환경의 환경 레코드)에 등록한다.

평가가 끝나면 소스코드가 순차적으로 실행되는 런타임이 시작된다. 이 때 변수나 함수의 참조는 실행 컨텍스트가 관리하는 스코프에서 식별자를 검색하여 사용한다. 또한 변수 값의 변경 같은 코드 실행 결과는 다시 실행 컨텍스트가 관리하는 스코프에 등록된다.

즉, 실행 컨텍스트는 실행 컨텍스트 스택과 렉시컬 환경으로 구성된다.

## 예제

실행 컨텍스트의 작동 예제를 알아보자.

```js
const x = 1;
const y = 2;

function foo(a) {
  const x = 10;
  const y = 20;
  console.log(a + x + y);
}

foo(100);

console.log(x + y);
```

1. 전역 코드 평가

   소스코드는 실행 전에 평가 과정을 거친다고 했다. 먼저 전역 코드를 평가하면서 전역 코드 내의 선언문을 실행한다. 이 결과로 생성된 전역 변수, 전역 함수가 **실행 컨텍스트가 관리하는 전역 스코프에 등록**된다.

2. 전역 코드 실행

   코드 평가 과정이 끝나면 런타임이 시작되어 전역 코드가 순차적으로 시작된다. 변수 x ,y 에 값이 할당되고 함수 foo가 호출된다.

3. 함수 코드 평가

   함수를 만나면 함수 내부로 진입하여 마찬가지로 실행 전에 평가 과정을 거친다. 매개변수와 함수 내에 선언된 진역 변수 선언이 먼저 실행되고, 그 결과로 생성된 매개변수, 지역 변수가 실행 컨텍스트가 관리하는 지역 스코프에 등록이 된다. 또한 arguments 객체가 생성되어 지역 스코프에 등록되고 this 바인딩도 결정된다.

4. 함수 코드 실행

   평가 과정이 끝나면 순차적으로 실행된다. 이때 매개변수 a 와 지역 변수 x, y 에 값이 할당 되고 그 다음 console 메서드가 호출된다.  
   js 는 식별자 검색을 위한 메커니즘으로 스코프 체인을 사용한다고 하였다. console 식별자를 찾기 위해서 스코프 체인을 사용한다. 하지만 console 은 전역 객체의 프로퍼티이지 전역 변수가 아니므로 이 검색을 위해서는 **전역 객체의 프로퍼티도 스코프 체인을 통해 검색이 가능하도록 뭔가 작업이 필요하다.**

   일단 이게 되었다고 하면 console.log 에서 log 라는 console 객체의 메서드를 검색하게 된다. js는 객체의 프로퍼티와 메서드 검색을 위해서 프로토타입 체인을 이용한다고 하였다. 이를 이용해 log 메서드를 검색한 후 표현식 console.log의 인수인 a + x + y 가 평가된다. a, x, y 는 식별자이므로 스코프 체인을 통해서 검색한다.

   console.log가 실행되고 나면 함수 코드는 모두 실행되었으므로 종료되고 다시 전역 코드로 돌아가서 실행이 마저 진행된다. 그래서 마지막 console.log(x + y)가 아까와 같은 방식으로 프로토타입 체인과 스코프 체인을 통해 검색되고 실행된다.

결국 코드가 실행되려면 식별자들을 스코프를 구분하여 등록하고 바인딩된 값을 관리할 수 있어야 하며, 스코프 체인을 형성해야 하고, 코드 실행 순서를 제어할 수 있어야 한다.

이 모든 것을 관리 하는 것이 실행 컨텍스트이다. 소스코드 실행해 필요한 위와 같은 환경을 제공하고 실행 결과를 관리하는 영역으로, 스코프와 코드 실행 순서 관리를 구현한 내부 메커니즘으로, 스코프는 **렉시컬 환경**으로 코드 실행 순서 관리는 **실행 컨텍스트 스택**으로 관리한다.

## 실행 컨텍스트 스택

4가지 타입으로 분류되는 js의 소스코드는 실행 컨텍스트를 생성하게 되는데, 소스코드에 의해서 생성된 실행 컨텍스트는 스택 자료구조로 관리되며 이것을 실행 컨텍스트 스택 (또는 콜 스택)이라고 부른다.

스택은 차례대로 쌓이는 것을 추상화한 자료구조로 스택의 위에 있는 순서대로 실행하는 특징을 가지고 있다. 소스코드가 실행 컨텍스트를 생성하게 되면 스택에 쌓이게 (push) 되며, 실행이 끝나서 종료되면 실행 컨텍스트는 스택에서 pop되게 된다.

따라서 아까의 예제를 보자면 전역 코드가 평가되어 전역 실행 컨텍스트를 생성하고 이것이 실행 컨텍스트 스택에 쌓이게 (push) 된다.

```

[전역 실행 컨텍스트    ]
```

그리고 전역 코드 실행 도중에 foo가 호출되어서 foo 내부로 제어권이 이동하고, 함수 foo 가 평가되어 또 실행 컨텍스트를 생성하게 되면 스택에 쌓이게 된다. 이때 전역 코드가 생성한 실행 컨텍스트는 여전히 스택에 있으므로, 이 위에 함수 실행 컨텍스트가 쌓이게 된다.

```
[함수 foo 실행 컨텍스트]
[전역 실행 컨텍스트    ]
```

그리고 foo가 실행을 마치고 종료되면 함수 foo 실행 컨텍스트는 스택에서 빠지게 (pop) 된다. 그리고 다시 전역 코드로 제어권이 이동하여 전역 코드를 실행한다.

```

[전역 실행 컨텍스트    ]
```

전역 코드도 실행이 전부 끝나서 종료되면 전역 실행 컨텍스트도 pop 된다.

```


```

이처럼 실행 컨텍스트 스택은 코드의 실행 순서를 관리하며 언제나 스택의 맨 위에 있는 실행 컨텍스트를 생성한 코드가 실행되게 된다.  
따라서 다음 예제에서 콘솔은 세번째 -> 두번째 -> 첫번째 순으로 찍힌다. first의 콘솔이 찍히기 전에 second 호출로 second 실행 컨텍스트가 위에 쌓이고, second 콘솔 찍히기 전에 third 호출로 third 실행 컨텍스트가 또 위에 쌓인다. 맨 위에 있는 실행 컨텍스트를 생성한 코드부터 실행되므로 그렇다.

```js
function first() {
  second();
  console.log('첫번째');
}
function second() {
  third();
  console.log('두번째');
}
function third() {
  console.log('세번째');
}
first();
```

## 렉시컬 환경
