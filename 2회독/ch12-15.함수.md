# 12. 함수

## 함수의 정의

일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.

함수 내부로 입력을 전달받는 변수를 **매개변수**, 입력(즉 실제 받는 값)을 인수, 출력을 반환값이라고 한다. 함수는 값이며, 식별자인 함수 이름을 쓸 수 있다.

함수는 함수 정의로 생성되며, 별도로 함수 호출을 해야 실행된다.

함수는 코드의 재사용성에서 매우 유용하다.

## 함수 리터럴

js에서는 함수 또한 리터럴로 생성이 가능하다.

- function 키워드
- 함수 이름 : 식별자이므로 식별자 네이밍 규칙을 준수해야 한다. 함수 몸체 내에서만 참조할 수 있으며 생략이 가능하다.
- 매개변수 목록 : () 안에 작성하며 호출 시 지정한 인수가 **순서대로** 할당 된다. 함수 내에서 변수로 사용이 가능하며 식별자 네이밍 규칙을 준수하야 한다.
- 함수 몸체 : 호출시 일괄적으로 실행되는 문들이다.

```js
function add(x, y) {
  return x + y;
}
```

함수 리터럴은 리터럴이므로 런타임에 평가되어서 값(객체)을 생성한다.

## 함수의 정의

### 함수 선언문

함수 리터럴과 형태가 동일하나 이름을 생략할 수 없다. 함수 리터럴과 달리 **표현식이 아닌 문**으로 변수에 할당할 수 없다.

```js
function add(x, y) {
  return x + y;
}
```

그러면 함수 리터럴(은 표현식임)은 변수에 할당할 수 있는데, 같은 모양을 가진 함수 선언문은 그럴 수 없다? 그렇다면 이 두 개를 어떻게 구분하는 것인가.

js 엔진은 이러한 중의적 표현을 문맥에 따라서 해석한다. 예컨대 변수 할당이나 피연산자 등 값이 들어갈 자리에는 같은 모양이라도 함수 리터럴로, 값이 들어가는 자리가 아닌 경우에는 함수 선언문으로 해석한다.

다시 함수 선언문으로 돌아와서, 함수 선언문으로 선언한 함수는 호출할 수 있다. 헌데 함수 이름(식별자)는 함수 몸체 내에서만 참조할 수 있다고 하였는데 어떻게 외부에서 식별자를 통해 호출할 수 있는 것인가? 이것은 js 엔진이 호출을 위해 함수 이름과 같은 이름의 식별자를 암묵적으로 생성하고, 거기게 함수 객체를 할당한다. 그러니까 사실 함수 이름이 아닌 (js가 암묵적으로 생성한) 식별자로 호출한 것이다.

### 함수 표현식

함수는 객체 타입의 값이므로 평가되어 값(함수)을 생성하는 함수 리터럴을 변수에 할당하는 것이 가능하며 이러한 정의 방식을 함수 표현식이라고 한다.

```js
var add = function foo(x, y) {
  return x + y;
};
```

이 경우 함수 이름으로는 외부에서 호출이 불가능하며 함수 이름은 생략이 가능하다.

```js
var add = function (x, y) {
  return x + y;
};

add(2, 5);
```

### 호이스팅

함수 선언문은 (다른 선언문들이 그렇듯) 런타임 이전에 실행되어 함수 객체를 생성하고, 함수 이름고 같은 식별자를 암묵적으로 생성하여 거기에 생성된 함수 객체를 할당한다. 따라서 함수 선언문을 함수 호이스팅이 발생하며 함수 호출이 함수 선언문보다 코드 상의 위쪽에 있어도 실행이 가능하다.

반면 함수 표현식은 변수에 함수 리터럴을 할당하는 것이다. 함수 리터럴이 할당 된 변수는 런타임 이전에 생성되지만 undefined로 초기화 되어 있을 뿐이다. 변수에 할당되는 함수 리터럴의 평가는 **할당문이 실행되는 시점인 런타임에 이루어 지므로** 함수 객체가 생성되는 시점은 변수가 초기화된 이후이다.

따라서 함수 표현식보다 코드 위쪽에서 해당 함수를 호출하게 되면 그 시점에서는 변수는 undefined로 초기화 되어 있고 함수 객체가 생성되어 할당되기 이전이므로 undefined를 함수 호출한 셈이 되어서 타입에러가 발생한다.

정리하자면 함수 선언문은 함수 호이스팅이, 함수 표현식은 변수 호이스팅이 발생한다.

### Function 생성자 함수

빌트인 생성자 함수 Function을 new 연산자와 함께 매개변수 목록과 함수 몸체를 문자열로 전달하면서 호출하면 함수 객체가 생성되어 반환된다.

```js
var add = new Function('x', 'y', 'return x + y');
```

이 방법은 일반적이지 않고 원장되지 않는다.

### 화살표 함수

간략한 표현으로 함수를 생성할 수 있으며 항상 무기명 함수로 정의한다. ES6에서 추가되었으며 단순히 표현의 차이 뿐만 아니라 여러 기능 동작의 설계에서도 차이점이 있다. 나중에 화살표 함수 파트에서 살펴보자.

```js
const add = (x, y) => x + y;
```

## 함수 호출

함수 호출은 함수 객체를 바인딩한 식별자와 소괄호 안에 0 개 이상의 인수를 쉼표로 구분해서 호출한다.

```js
function add(x, y) {
  return x + y;
}

add(2, 5);
```

### 매개변수와 인수

인수는 함수 호출시 지정하며, 매개변수를 통해 함수 내부로 전달된다. 인수는 개수와 타입에 제한이 없다. 매개변수는 함수 몸체 내부에서 변수와 동일하게 취급된다. 변수처럼 함수 몸체 실행시 undefined로 초기화 된 후, 인수의 값으로 할당이 된다.
함수는 매개변수와 전달된 인수의 개수가 같은지 체크하지 않는다. 인수가 모자라면 남은 매개변수는 undefined로 남아있게 된다. 인수가 남으면 무시되지만 함수 내부의 arguments 객체에 저장은 되어 있다.

### 인수 확인

함수는 인수의 개수를 확인하지 않은 뿐만 아니라 매개변수의 타입을 사전에 지정할 수 없으므로 어떤 타입의 인수를 전달하여도 그대로 실행한다.  
이는 개발자의 설계 의도와는 다르게 동작할 위험성이 있으며 부적절한 호출에 의한 에러는 실제로 함수가 호출되는 런타임에 발생하게 되므로 대비가 필요하다.

해결책 몇 가지가 있다.

- 함수 몸체 내에서 if문 등으로 인수의 타입을 확인한다.
- 단축 평가를 통해 인수가 전달되지 않은 경우 기본으로 쓸 값을 설정한다.
- ES6 에서 도입된 매개변수 기본값을 사용할 수 있다.

```js
// 매개변수에 undefined를 전달하거나 매개변수를 전달하지 않았을 경우에만 작동한다.
function add(a = 0, b = 0) {
  return a + b;
}
```
