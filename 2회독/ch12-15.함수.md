# 12. 함수

## 함수의 정의

일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.

함수 내부로 입력을 전달받는 변수를 **매개변수**, 입력(즉 실제 받는 값)을 인수, 출력을 반환값이라고 한다. 함수는 값이며, 식별자인 함수 이름을 쓸 수 있다.

함수는 함수 정의로 생성되며, 별도로 함수 호출을 해야 실행된다.

함수는 코드의 재사용성에서 매우 유용하다.

## 함수 리터럴

js에서는 함수 또한 리터럴로 생성이 가능하다.

- function 키워드
- 함수 이름 : 식별자이므로 식별자 네이밍 규칙을 준수해야 한다. 함수 몸체 내에서만 참조할 수 있으며 생략이 가능하다.
- 매개변수 목록 : () 안에 작성하며 호출 시 지정한 인수가 **순서대로** 할당 된다. 함수 내에서 변수로 사용이 가능하며 식별자 네이밍 규칙을 준수하야 한다.
- 함수 몸체 : 호출시 일괄적으로 실행되는 문들이다.

```js
function add(x, y) {
  return x + y;
}
```

함수 리터럴은 리터럴이므로 런타임에 평가되어서 값(객체)을 생성한다.

## 함수의 정의

### 함수 선언문

함수 리터럴과 형태가 동일하나 이름을 생략할 수 없다. 함수 리터럴과 달리 **표현식이 아닌 문**으로 변수에 할당할 수 없다.

```js
function add(x, y) {
  return x + y;
}
```

그러면 함수 리터럴(은 표현식임)은 변수에 할당할 수 있는데, 같은 모양을 가진 함수 선언문은 그럴 수 없다? 그렇다면 이 두 개를 어떻게 구분하는 것인가.

js 엔진은 이러한 중의적 표현을 문맥에 따라서 해석한다. 예컨대 변수 할당이나 피연산자 등 값이 들어갈 자리에는 같은 모양이라도 함수 리터럴로, 값이 들어가는 자리가 아닌 경우에는 함수 선언문으로 해석한다.

다시 함수 선언문으로 돌아와서, 함수 선언문으로 선언한 함수는 호출할 수 있다. 헌데 함수 이름(식별자)는 함수 몸체 내에서만 참조할 수 있다고 하였는데 어떻게 외부에서 식별자를 통해 호출할 수 있는 것인가? 이것은 js 엔진이 호출을 위해 함수 이름과 같은 이름의 식별자를 암묵적으로 생성하고, 거기게 함수 객체를 할당한다. 그러니까 사실 함수 이름이 아닌 (js가 암묵적으로 생성한) 식별자로 호출한 것이다.

### 함수 표현식

함수는 객체 타입의 값이므로 평가되어 값(함수)을 생성하는 함수 리터럴을 변수에 할당하는 것이 가능하며 이러한 정의 방식을 함수 표현식이라고 한다.

```js
var add = function foo(x, y) {
  return x + y;
};
```

이 경우 함수 이름으로는 외부에서 호출이 불가능하며 함수 이름은 생략이 가능하다.

```js
var add = function (x, y) {
  return x + y;
};

add(2, 5);
```

### 호이스팅

함수 선언문은 (다른 선언문들이 그렇듯) 런타임 이전에 실행되어 함수 객체를 생성하고, 함수 이름고 같은 식별자를 암묵적으로 생성하여 거기에 생성된 함수 객체를 할당한다. 따라서 함수 선언문을 함수 호이스팅이 발생하며 함수 호출이 함수 선언문보다 코드 상의 위쪽에 있어도 실행이 가능하다.

반면 함수 표현식은 변수에 함수 리터럴을 할당하는 것이다. 함수 리터럴이 할당 된 변수는 런타임 이전에 생성되지만 undefined로 초기화 되어 있을 뿐이다. 변수에 할당되는 함수 리터럴의 평가는 **할당문이 실행되는 시점인 런타임에 이루어 지므로** 함수 객체가 생성되는 시점은 변수가 초기화된 이후이다.

따라서 함수 표현식보다 코드 위쪽에서 해당 함수를 호출하게 되면 그 시점에서는 변수는 undefined로 초기화 되어 있고 함수 객체가 생성되어 할당되기 이전이므로 undefined를 함수 호출한 셈이 되어서 타입에러가 발생한다.

정리하자면 함수 선언문은 함수 호이스팅이, 함수 표현식은 변수 호이스팅이 발생한다.

### Function 생성자 함수

빌트인 생성자 함수 Function을 new 연산자와 함께 매개변수 목록과 함수 몸체를 문자열로 전달하면서 호출하면 함수 객체가 생성되어 반환된다.

```js
var add = new Function('x', 'y', 'return x + y');
```

이 방법은 일반적이지 않고 원장되지 않는다.

### 화살표 함수

간략한 표현으로 함수를 생성할 수 있으며 항상 무기명 함수로 정의한다. ES6에서 추가되었으며 단순히 표현의 차이 뿐만 아니라 여러 기능 동작의 설계에서도 차이점이 있다. 나중에 화살표 함수 파트에서 살펴보자.

```js
const add = (x, y) => x + y;
```

## 함수 호출

함수 호출은 함수 객체를 바인딩한 식별자와 소괄호 안에 0 개 이상의 인수를 쉼표로 구분해서 호출한다.

```js
function add(x, y) {
  return x + y;
}

add(2, 5);
```

##

매개변수와 인수

인수는 함수 호출시 지정하며, 매개변수를 통해 함수 내부로 전달된다. 인수는 개수와 타입에 제한이 없다. 매개변수는 함수 몸체 내부에서 변수와 동일하게 취급된다. 변수처럼 함수 몸체 실행시 undefined로 초기화 된 후, 인수의 값으로 할당이 된다.
함수는 매개변수와 전달된 인수의 개수가 같은지 체크하지 않는다. 인수가 모자라면 남은 매개변수는 undefined로 남아있게 된다. 인수가 남으면 무시되지만 함수 내부의 arguments 객체에 저장은 되어 있다.

### 인수 확인

함수는 인수의 개수를 확인하지 않은 뿐만 아니라 매개변수의 타입을 사전에 지정할 수 없으므로 어떤 타입의 인수를 전달하여도 그대로 실행한다.  
이는 개발자의 설계 의도와는 다르게 동작할 위험성이 있으며 부적절한 호출에 의한 에러는 실제로 함수가 호출되는 런타임에 발생하게 되므로 대비가 필요하다.

해결책 몇 가지가 있다.

- 함수 몸체 내에서 if문 등으로 인수의 타입을 확인한다.
- 단축 평가를 통해 인수가 전달되지 않은 경우 기본으로 쓸 값을 설정한다.
- ES6 에서 도입된 매개변수 기본값을 사용할 수 있다.

```js
// 매개변수에 undefined를 전달하거나 매개변수를 전달하지 않았을 경우에만 작동한다.
function add(a = 0, b = 0) {
  return a + b;
}
```

### 매개변수의 개수

js는 (엔진의 물리적 한계에 다다르기 전까지는) 충분히 많은 수의 매개변수를 함수에 지정할 수 있다. 하지만 매개변수가 많아지는 것은 함수가 여러가지 일을 한다는 뜻이며 호출시 인수의 순서를 고려해야 하는 복잡함이 증가하므로 최대한 적을 수록 좋다.  
만약 3개 이상의 매개변수가 꼭 필요하다면 매개변수를 객체로 만들어 전달하는 것이 낫다.

## 반환문

함수 몸체 내에서 return 키워드와 표현식으로 이루어진 반환문으로 결과를 외부로 반환할 수 있다. 반환문이 반환하는 값은 함수 호출(표현식)의 평가 결과가 된다.

- return 문이 실행되면 함수 실행을 종료하므로 그 뒤에 오는 문은 실행되지 않는다.
- return 뒤에 아무것도 쓰지 않으면 undefined를 반환하면 반환문 자체를 생략해도 undefined를 반환한다.
- 함수 몸체 내에서만 사용이 가능하다.

## 참조에 의한 전달과 외부 상태의 변경

매개변수는 함수 몸체 내부에서 변수와 동일하게 취급되므로, 매개변수로 값을 전달하는 것은 일전에 살펴보았던 **값이 할당된 변수를 다른 변수에 할당**하는 것과 같은 방식으로 작동한다.  
따라서 함수 몸체 내에서 전달 받은 원시 값을 변경하여도 새로운 메모리 주소에 값 자체가 복사되어 전달되므로 외부의 값에는 영향을 미치지 않지만, 반면 객체를 전달 받아서 변경하면 전달해준 외부 객체의 변화가 생긴다. 이것은 코드를 복잡하게 만드는 것이므로 좋지 않다.

이러한 해결책 중 하나는 객체를 불변 객체로 만들어서 복사본을 완전히 새로 만드는 비용을 지불하고 재할당을 통해 교체하는 방법이 있다.

## 다양한 함수의 형태

### 즉시 실행 함수 (IIFE)

함수 정의돠 동시에 호출되는 함수이다. 단 한번만 호출되며 다시 호출이 불가능하다.

```js
(function () {
  var a = 3;
  var b = 5;
  return a + b;
})();
```

그룹 연산자 ()내에는 값으로 평가될 수 있어야 하므로 위에서 () 내의 문은 함수 선언문이 아니라 함수 리터럴로 해석되어 함수 객체를 생성한다. 그리로 뒤에 붙은 ()는 함수 호출 연산자로 해석되어 함수를 호출한다.

함수는 익명으로 보통 하지만 기명으로 써도 상관없다. 다만 함수 리터럴로 해석되기 때문에 함수 이름이 함수 내부에서만 식별할 수 있게 되어서 외부에서 호출은 불가능하다.

즉시 실행 함수 또한 일반 함수처럼 값을 반환하거나 인수를 전달할 수 있다.

```js
var res = (function () {
  var a = 3;
  var b = 5;
  return a + b;
})();

console.log(res); // 8

var res = (function (a, b) {
  return a + b;
})(3, 5);
```

### 재귀 함수

함수가 자기 자신을 호출하는 함수를 재귀 함수라고 한다.

```js
function factorial(n) {
  if (n <= 1) return 1;
  return n * factorial(n - 1);
}
```

재귀 함수는 함수가 무한히 호출되지 않게 반드시 탈출 조건을 만들어야 한다. 그러지 않는 경우 스택 오버플로우 에러가 발생하게 된다. 이러한 위험성 때문에 반복문보다 재귀 함수를 사용한 것이 더 이해하기 쉬울 때에만 제한적으로 사용하는 것이 좋다.

### 중첩 함수

함수 내부에 정의된 함수를 중첩 함수(내부 함수)라고 부르며 중첩 함수를 포함하는 함수를 외부 함수라고 부른다. 중첩 함수는 외부 함수 내부에서만 호출할 수 있으며, 보통 외부 함수의 기능을 돕는 헬퍼 함수의 역할을 한다.

### 콜백 함수

로직의 일부분이 같은 작업을 반복해야 하는 경우, 매번 함수를 새로 만드는 것 보다 함수의 합성을 이용하는 것이 효율적으로 문제를 해결할 수 있다.
함수의 공통 로직은 미리 정의해 두고, 변화하는 부분은 함수 외부에서 추상화해서(다른 함수로 만들어서) 공통 로직은 정의한 함수 내부로 전달한다.  
이 때 함수의 매개변수를 통해서 다른 함수의 내부로 전달되는 함수를 콜백 함수, 콜백 함수를 전달받은 함수를 고차 함수 라고 부른다.

```js
function repeat(n, f) {
  for (var i = 0; i < n; i++) {
    f(i);
  }
}
// 이 함수는 어떠한 작업을 n 번 반복한다는 로직을 가지고 있다. n 번 반복해야 하는 작업이 다양한 경우, 그때마다 일일히 함수를 만드는 것 보다 저렇게 공통된 부분을 미리 작성한 후 다른 부분을 repeat의 인자로 전달하면 된다.

var logAll = function (i) {
  console.log(i);
};
var logOdds = function (i) {
  if (i % 2) console.log(i);
};
// 서로 다른 로직을 가지는 부분을 따로 작성하였다.

repeat(5, logAll);
repeat(10, logOdds);
// 필요한 부분을 매개변수를 통하여 전달한다.
```

고차 함수는 콜백 함수를 자신의 몸체 내에서 호출하게 된며 필요에 따라서 인자를 전달한다. 따라서 콜백 함수를 호출하는 것이 아닌 고차 함수에 콜백 함수 자체를 전달해야만 한다.

전달 방법에는 2가지가 있다. 먼저 고차 함수의 매개변수 자리에 함수를 정의하는 방법이다. 매개변수 자리에는 값이 들어가는 자리 이므로 익명 함수 리터럴로 평가가 되어 전달된다.

```js
repeat(5, function (i) {
  if (i % 2) console.log(i);
}); // 인수로 직접 함수를 작성
```

아니면 위의 예제처럼 따로 함수를 작성해 두고 인자로 전달한다.

### 순수 함수

부수 효과가 없는 함수, 즉 외부 상태에 의존하지 않고 외부 상태를 변경하지도 않는 함수를 함수형 프로그래밍 패러다임에서는 **순수 함수**라고 일컫는다.  
외부 상태가 아닌 매개변수를 통해 전달된 인수에만 의존하여 값을 생성하므로, 호출될때마다 항상 같은 값을 반환한다. 또한 인수를 변경하지 않는 것이 기본이다.

또한 외부 상태를 변경하지도 않는다고 하였다.

```js
var count = 0;

// increase는 인수에만 의존하여 값을 생성하고, 외부 상태를 변경하지 않으므로 순수 함수이다.
function increase(n) {
  return ++n;
}

// 외부 상태인 count의 값에 따라서 리턴값이 변하므로 외부 상태에 의존하며, 또한 외부 상태인 count 변수의 값을 변경하는 비순수 함수이다.
function increaseCount() {
  return ++count;
}
```

위와 같은 비순수 함수는 상태 변화를 추적하기 어렵게 된다는 단점을 가지고 있다. 따라서 이런 형태의 함수는 코드를 복잡하게 하므로 지양하는 것이 좋으며 이러한 문제가 발생하지 않도록 순수 함수와 보조 함수의 조합을 통하여 부수 효과를 최대한 없애서 불변성을 지향하고 코드의 안정성을 지향하는 프로그래밍 패러다임을 함수형 프로그래밍이라고 부른다.

# 13. 스코프
